<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Two-Line Element(TLE) Model</title>
    <url>/2021/10/19/20211019-Two-Line-Element-TLE-Model/</url>
    <content><![CDATA[<h3 id="TLE"><a href="#TLE" class="headerlink" title="TLE"></a>TLE</h3><ul>
<li>两轨道要素形式：Two-line element set，是一种轨道编码方式，用于确定给定时刻下，绕地运行空间目标的轨道根数。使用合适的预测模型，可以以一定精度估计出目标在轨道上任意一点的位置和速度。</li>
</ul>
<span id="more"></span>
<ul>
<li>TLE轨道根数对应的计算模型是简化普适模型（Simplified Perturbations models,包括SGP, SGP4, SDP4, SGP9, SDP8）。使用TLE数据的算法必须使用以一种简化普适模型准确计算出轨道的参数。；</li>
<li>两行轨道要素采用两行80字符的ASCII码来存储数据，这种方式起源于一张卡打印一行的打孔卡。美国空军负责跟踪地球轨道上所有可探测物体，并为每个目标生成相应的TLE轨道根数，并把非保密目标的TLE数据公布在Space Track网站。</li>
<li>事实上，在发布地球轨道目标的轨道要素时，TLE轨道根数是一种事实上的标准，需要注意的是，TLE轨道根数仅可以表述<strong>绕地球运行物体的轨道</strong>。</li>
<li>另外，在轨道要素行的前面，TLE轨道数据也许会包含一行标题，所以每一组TLE数据也许会占据文本中的三行。但是标题行并不是必需的，因为每一个轨道数据行都包含了一个独一无二的目标编号。</li>
</ul>
<hr>
<h3 id="NORAD-Two-Line-Element-Set-Format"><a href="#NORAD-Two-Line-Element-Set-Format" class="headerlink" title="NORAD Two-Line Element Set Format"></a>NORAD Two-Line Element Set Format</h3><p>Data for each satellite consists of three lines in the following format:</p>
<ul>
<li><pre><code class="lang-shell">AAAAAAAAAAAAAAAAAAAAAAAA
1 NNNNNU NNNNNAAA NNNNN.NNNNNNNN +.NNNNNNNN +NNNNN-N +NNNNN-N N NNNNN
2 NNNNN NNN.NNNN NNN.NNNN NNNNNNN NNN.NNNN NNN.NNNN NN.NNNNNNNNNNNNNN

# Example:
STARLINK-1008           
1 44714U 19074B   21296.34162117 -.00000683  00000-0 -26977-4 0  9990
2 44714  53.0544 161.8865 0001587  81.1880 278.9289 15.06384408108019
</code></pre>
</li>
</ul>
<p>Line 0 is a twenty-four character name (to be consistent with the name length in the NORAD SATCAT).</p>
<p>Lines 1 and 2 are the standard Two-Line Orbital Element Set Format identical to that used by NORAD and NASA. The format description is:</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://www.youtube.com/watch?v=NQTtFrhSNDk">https://www.youtube.com/watch?v=NQTtFrhSNDk</a></li>
<li><a href="https://www.youtube.com/watch?v=u4rYYbBdr28">https://www.youtube.com/watch?v=u4rYYbBdr28</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%B8%A4%E8%A1%8C%E8%BD%A8%E9%81%93%E8%A6%81%E7%B4%A0%E5%BD%A2%E5%BC%8F">https://zh.wikipedia.org/wiki/%E4%B8%A4%E8%A1%8C%E8%BD%A8%E9%81%93%E8%A6%81%E7%B4%A0%E5%BD%A2%E5%BC%8F</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>卫星互联网基本概念</title>
    <url>/2021/10/20/20211020-%E5%8D%AB%E6%98%9F%E4%BA%92%E8%81%94%E7%BD%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="1-联系"><a href="#1-联系" class="headerlink" title="1. 联系"></a>1. 联系</h1><blockquote>
<p>信息网络发展历程：传统有线网络、无线网络、卫星网络</p>
<p>天地一体化信息网络 = 卫星网络 + 地面网络</p>
<p>5G+satellite != 5G+satellite network</p>
<p>卫星互联网、5G、6G</p>
<p><strong>卫星互联网 = 卫星通信+互联网</strong></p>
<blockquote>
<p>互联网是各种网络互联而成（卫星通信只是手段），其实“卫星互联网”这个叫法并不专业。</p>
</blockquote>
</blockquote>
<span id="more"></span>
<p><strong>1. 卫星互联网与地面互联网的区别与联系？</strong></p>
<ul>
<li>都基于IP</li>
</ul>
<p><strong>2. 卫星互联网与移动通信网（4G/5G）的区别与联系？</strong></p>
<ul>
<li>网络和通信的区别，卫星网络和地面通信的区别</li>
</ul>
<p><strong>3. 卫星互联网与天基物联网的区别与联系？</strong></p>
<ul>
<li>网络互联和典型应用的关系</li>
</ul>
<p><strong>4. 卫星互联网与量子通信网络等新型网络的关系？</strong></p>
<ul>
<li>需要看量子通信网络的发展和其能真正解决的问题，再定……</li>
</ul>
<p><strong>5. 卫星通信 &amp; 卫星互联网</strong></p>
<ul>
<li>对卫星通信而言，星间星地链路切换，意味着网络拓扑连接关系改变，对应调整路由交换表以保持联系。可以说，高动态拓扑是导致卫星通信性能下降的直接原因；</li>
<li>对卫星网络而言，星间星地链路切换，意味着网络间的连接关系改变，为此进行域内、域间路由重计算，从而得到新的网络间的拓扑关系。可以说，不断链路切换导致的路由重计算是导致卫星网络性能下降的直接原因，也是卫星网络拓扑高动态的直接原因。</li>
</ul>
<p><strong>6. 研究问题</strong></p>
<ul>
<li>互联网是人类发明创造的，而在这个伟大的发明中，却没有考虑互联网世界的时空基准。互联网的用户编址与真实的空间位置无关，其寻址只是基于用户逻辑划分的IP源、目的地址。面向未来互联网，虚拟的网络环境必然与现实的物理世界融合一体，如何解决真实世界与虚拟网络的同意时空基准与定位和寻址；</li>
<li>卫星网络与地面面网络以及用户的不断切换，导致由于接入不同的卫星，用户从卫星分配的IP地址，以及接入的地网设施需要不断重负巨量的地址更新，实现编制和寻址与星间星地链路切换相解耦的方法；</li>
<li>保持IP编址的全网统一、唯一与兼容的同时，又支持卫星网络自治域内支持新型的用户编制方式。</li>
</ul>
<hr>
<h1 id="2-具体概念解释"><a href="#2-具体概念解释" class="headerlink" title="2. 具体概念解释"></a>2. 具体概念解释</h1><h3 id="卫星互联网：starlink"><a href="#卫星互联网：starlink" class="headerlink" title="卫星互联网：starlink"></a>卫星互联网：starlink</h3><blockquote>
<p>传统的4G5G通信都是通过基站来组网；</p>
<p>卫星互联网，就是将传统意义的基站建到太空卫星上去，通过一定数量的围绕地球轨道运转的卫星组成动态交错网络，实现全球所有地区的通信信号覆盖。</p>
</blockquote>
<p><strong>卫星互联网的优势</strong></p>
<blockquote>
<ul>
<li>减少大量基建成本</li>
<li>全球范围信号无死角覆盖</li>
<li>替代有线接入方案</li>
</ul>
</blockquote>
<p><strong>存在问题</strong></p>
<blockquote>
<ul>
<li><p>每个卫星的通信容量有限；</p>
</li>
<li><p>高并发量的通信会给卫星群带来极大的负载压力；</p>
</li>
<li>卫星数量过多，会影响天文观测，或造成太空垃圾；</li>
<li>卫星信号接收终端的技术有待提升；</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>卫星组网</title>
    <url>/2021/10/20/20211020-%E5%8D%AB%E6%98%9F%E7%BB%84%E7%BD%91/</url>
    <content><![CDATA[<p><strong>卫星宇宙知识</strong></p>
<ul>
<li>物理定律<blockquote>
<ol>
<li>卫星轨道为椭圆；</li>
<li>相同时间内，小天体和大天体之间连线扫过的面积相等（面积定律）；</li>
<li>公转周期T的平方和轨道椭圆半长轴a的立方成反比；</li>
</ol>
</blockquote>
</li>
</ul>
<span id="more"></span>
<ul>
<li><p>常用轨道</p>
<blockquote>
<p>GEO【Geostationary Earth Orbit】：地球静止轨道，35768km；</p>
<p>LEO【Low  Earth Orbit】：低轨卫星，700-2000km；</p>
<p>MEO【Medium Earth Orbit】：中轨卫星，8000-20000km；</p>
<p>后两种术语非同步轨道卫星，需要通过卫星星座实现全球覆盖，一般有两种卫星星座的标记法，即星座的两种网络部署结构：<strong>Walker构型码</strong>和<strong>Ballad构型码</strong>.</p>
</blockquote>
</li>
<li><p>传输频段</p>
<blockquote>
<p>C【4-8GHz】：固定卫星业务</p>
<p>X【8-12GHz】</p>
<p>Ku【12-18GHz】：趋于饱和，新一代宽带卫星使用Ka频段；</p>
<p>K【18-27GHz】</p>
<p>Ka【27-40GHz】</p>
<p> <img src="\images\doc\11.png" alt="image-20211020102932177" style="zoom:50%;" /></p>
</blockquote>
</li>
</ul>
<hr>
<p><strong>通信基础知识</strong></p>
<ul>
<li><p><strong>多址技术</strong></p>
<blockquote>
<ol>
<li>频分多址FDMA</li>
<li>时分多址TDMA</li>
<li>码分多址CDMA</li>
</ol>
</blockquote>
</li>
</ul>
<hr>
<p><strong>通信卫星基本工作流程</strong></p>
<ul>
<li><p><strong>基本体系架构</strong></p>
<blockquote>
<ul>
<li><p>在卫星通信系统中，卫星覆盖范围内的所有终端设备及地球站通过发射天线利用反向链路将请求数据传输到多波束卫星；</p>
</li>
<li><p>多波束卫星接收信号并进行放大，通过反向链路转发至信关站，由信关站传输给地面网络进行处理；</p>
</li>
<li><p>地面网络处理完成后，将回复数据传输传输给信关站，信关站利用前向链路将回复数据发送到通信卫星，同样进行放大并通过反向链路转发至多波束小区。从而完成数据的请求与接收流程。【如果信关站与卫星覆盖小区不在同一颗卫星的覆盖范围内，则卫星需要将信号通过星间链路转发至目标卫星，然后由目标卫星发给信关站】</p>
<p><img src="/images/image-20211020103010276.png" alt="image-20211020103010276" style="zoom:50%;" /></p>
</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>常见LEO系统</strong></p>
<blockquote>
<ol>
<li>OneWeb：采用Ku+Ka波段；18*40，1200km，72°</li>
<li>SpaceX：采用Ku+Ka波段；4425颗；</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>组网的关键问题：</strong>【对于透明转发卫星，称为<strong>弯管卫星</strong>；对于星上处理或交换卫星，看作空中的网络节点】</p>
<blockquote>
<ul>
<li><strong>单跳连接：</strong>端到端的连接仅通过卫星路由一次，网络拓扑为星型结构。</li>
<li><strong>多跳链接：</strong>通过体面中心站放大通信终端间的信号，网络拓扑是以地面中心站为中心的星型结构。</li>
<li><strong>星间链路</strong><ul>
<li><strong>引入ISL的优点：</strong><ul>
<li>由于星间位置相对固定，从而在空中形成卫星网格，可以减少地面站、地空之间的业务流量，从而减少对有限空中频率资源的占用；</li>
<li>星间链路的频段主要为Ka频段以及频率更高的微波、毫米波和激光，其频带宽，通信容量大；</li>
</ul>
</li>
<li><strong>对于不同轨道平面的卫星，卫星链路带来的问题：</strong>卫星之间存在高速相对运动，由于天线摆动产生的跟踪控制问题，多普勒频移效应；</li>
</ul>
</li>
<li><strong>切换：</strong>要保持源和目的之间的链路必须切换。卫星覆盖区域随卫星移动，链路发生切。有两种卫星切换场景：<strong>轨道面内卫星切换</strong>和<strong>轨道面间卫星切换</strong>；<strong>卫星波束内切换</strong>和<strong>波束间切换</strong>；</li>
<li><strong>路由：</strong>卫星与同一轨道其他卫星相对位置保持不变，相对于地球终端和其他轨道卫星位置和传输时延连续变化，需要采用自适应路由技术。LEO网络中卫星的失效会导致通信孤岛，路由算法必须利用<strong>冗余链路和卫星</strong>容忍这些失效。<ul>
<li><strong>集中式路由算法：</strong>所有卫星将星座信息上报到一个中心节点，该节点随后计算路由发回所有卫星；</li>
<li><strong>分布式路由算法：</strong>所有卫星交换网络度量信息，在QoS和网络资源利用效率之间折衷；</li>
<li>从卫星网络特征角度可以氛围单层卫星网络路由算法和多层网络路由选择算法。单层如Werner等人提出的将ATM网络路由应用在LEO卫星网络上，将路由策略分为拓扑离散化、最优路径选择两个过程。关于多层卫星网络路由算法的研究主要包括以下几个方面：基于IP的路由算法，Lee等人提出分层QoS路由协议，将路由计算转移到MEO卫星，减少LEO层负载，使路由计算速度更快；流量平衡路由算法；QoS路由算法；组播路由算法；</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><p><strong>卫星与地面网络的互联</strong></p>
<blockquote>
<p>卫星承载SDH（数字同步系列Intelsat场景）</p>
<p>卫星和MANET（Mobile Wireless ad hoc network）    </p>
<ul>
<li>ad hoc网络需要关注的问题：路由技术的选择；配置和管理；有限的带宽；链路变化；隐藏节点问题；能源；移动性和动态拓扑；</li>
<li>卫星和MANET互联所面临的挑战：网络资源优化、链路可用度、QoS和QoE，以及最小化成本和能量；</li>
<li>与异构网络互联的一般性问题：业务、寻址、路由、演进</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><p><strong>卫星承载ATM</strong>【未阅读】</p>
<blockquote>
<p><strong>4.1卫星突发错误对ATM层的影响：</strong></p>
<p>ATM的设计是针对光纤那种拥有良好误码特性的物理介质，没有一般协议中处理不可靠信道的许多特性。突发错误对ATM层最主要的影响是信元丢失率（CLR）的剧烈增长。ATM信头中的8bit差错控制字段智能纠正1bit错误。对于突发错误，CLR与BER呈线性关系。</p>
<p>突发错误对AAL协议的影响</p>
<p>差错控制机制：</p>
<p>重传机制、前向纠错（FEC）和交织技术。使用FEC和交织技术可以减轻突发错误。</p>
<p><strong>4.2宽带卫星网络的增强技术：</strong></p>
<p>通过对多个信元的头部进行交织，可以实现随机单比特错误信道中ATM的性能目标。</p>
<p>RS码和卷积FEC码串联使用，性能优越。如果长度大于RS码能纠正的长度，错误突发应该扩散到多个码元，以便利用分组码的纠错能力。</p>
<p><strong>相关文献：</strong></p>
<p>A dynamic routing concept for ATM-based satellite personal communication networks</p>
<p>ATM-based routing in LEO/MEO satellite networks with intersatellite links</p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><p><strong>卫星承载IP</strong></p>
<blockquote>
<ul>
<li><strong>三种卫星承载IP的组网技术</strong><ul>
<li>卫星通信网络：提供传统卫星业务，通过点到点链路提供因特网接入和因特网子网互联；</li>
<li>基于VSAT概念的卫星共享介质包网络：支持数据服务类型的业务；</li>
<li>数字视频广播：经卫星基于DVB承载IP具有提供全球宽带接入的潜力；</li>
</ul>
</li>
</ul>
<ul>
<li><strong>卫星网络中的移动IP</strong><ul>
<li>家乡地址HoA：移动节点的标识，由家乡网络分配，通常不变；</li>
<li>转交地址CoA：移动节点的位置标识，由移动到的外地网络分配，随位置变化；</li>
<li>家乡代理Home Agent：保存移动节点的家乡地址和转交地址之间的映射关系；</li>
<li>移动IP = CoA发现 + CoA注册 + CoA隧道<ul>
<li><strong>CoA发现：</strong>代理公告和代理请求；</li>
<li><strong>CoA注册：</strong> 当移动节点进入外地代理的覆盖范围时注册程序启动，发送带有CoA信息的注册请求。家乡代理收到请求后将必要信息添加到路由表，然后批注请求，向移动节点发送对注册请求的应答；</li>
<li><strong>CoA隧道：</strong>隧道方式是所有移动代理都必须支持的默认封装方式；</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>卫星IP组播</strong></p>
<ul>
<li><p>组播：从单一源向多个目的传输数据（也包括多对多），如视频会议；</p>
</li>
<li><p>组播优势：降低对网络带宽的占用，降低源端处理负载；</p>
</li>
<li><p>可以是<strong>尽力而为</strong>的，也可以是<strong>可靠</strong>的；</p>
</li>
<li><p>IP组播路由：对于单播IP路由，路由表中包含通往指定IP目的地址的路径信息，但组播包中并不包含目的地址的位置信息。IP组播的范围由IP头部TTL字段控制；</p>
<blockquote>
<p>ETF开发了一组组播路由协议，包括DVMRP、PIM-SM、PIM-SM，CBT等。DVMRP、PIM-SM协议工作原理是“泛洪和剪枝”（ flood and prune）算法。</p>
</blockquote>
</li>
<li><p>星上可靠组播路由协议：与卫星链路相关的主要问题是<strong>误码特性</strong>和<strong>RTT</strong>。数据损坏意味着存在大量的组播端用户时，接收者会有很大概论收不到数据；高TRR影响实时通信，也会影响如FTP等网络协议。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>IP服务质量</strong></p>
<ul>
<li>综合服务两个关键特征：<strong>资源预留</strong>和<strong>会话建立</strong>；</li>
<li>QoS综合服务Intserv架构：为IP应用提供端到端的“硬”QoS保证，其中应用可以明确指定QoS需求，网络保证这些需求。</li>
<li>相关方法：资源预留（资源预留协议RSVP）、访问控制、流量分类、流量管控、排队和调度；</li>
<li>QoS区分服务Diffserv架构：区分服务目的是提供可扩展的服务区分能力，而且不要求综合服务架构那样的信令开销，提供不同方式处理不同等级流量的能力；<ul>
<li>两个功能要素：<strong>边缘功能</strong>（分组标记和流量调节）、<strong>核心功能</strong>（转发）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>卫星数字视频广播</strong><ul>
<li>DVB-S和DVB-RCS体系结构：星上处理器OBP，管理站，再生卫星网关RSGW，回传信道卫星终端RCST。</li>
<li>网络协议栈结构：RCST以对等（Peer to Peer）通信方式与其他RCST构成网状通信或星型通信模式。卫星无关业务访问协议（SI-SAP）位于链路层和网络层之间。卫星网络协议包括卫星链路控制（SLC）、卫星介质访问控制（SMAC）和物理（PHY）层。</li>
<li>SLC子层和网络层交换IP数据包；SMAC子层具有传送功能，即传输MPEG包突发和接受包含在TDM中的MPEG包。</li>
<li>RCST物理层负责在同步和位纠错功能的物理介质上传输数据。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><p><strong>卫星网络对传输层的影响</strong></p>
<blockquote>
<p><strong>卫星信道特点【有别于大多数地面信道，可能会降低TCP的性能】</strong></p>
<ul>
<li>长RTT：卫星高度引起的时延【GEO一次请求回复约半秒，700kmLEO约9ms】</li>
<li>高时延带宽积：任一时刻为充分利用信道容量，协议具有的在“飞行中”状态的数据的数量（即已经被传输出去还没有被确认的数据的数量）；</li>
<li>传输差错：卫星信道误比特率和地面网络相比更高。由于传输差错导致的丢包会引起TCP减小其滑动窗口；</li>
<li>非对称链路：卫星的上行链路带宽一般比下行链路带宽更小；</li>
<li>变化的RTT【端到端时延】：会影响重传超时的粒度；</li>
<li>间歇性连接：LEO卫星存在频繁切换，如果连接中断会导致丢包；</li>
</ul>
</blockquote>
</li>
</ul>
<p><a href="https://blog.csdn.net/farmer_/article/details/103369245?spm=1001.2101.3001.6650.18&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-18.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-18.no_search_link">转载</a></p>
]]></content>
  </entry>
  <entry>
    <title>Erasure Code</title>
    <url>/2021/10/21/20211021-Erasure-Code/</url>
    <content><![CDATA[<h3 id="Erasure-Code纠删码"><a href="#Erasure-Code纠删码" class="headerlink" title="Erasure Code纠删码"></a>Erasure Code纠删码</h3><ul>
<li><p><strong>什么是Erasure Code？</strong></p>
<blockquote>
<p>可以认为是RAID的通式。任何RAID都可以转换为特定的Erasure Code。</p>
<p>传统的RAID仅支持少量的磁盘分布，当系统中存在多个分发点和多个节点时，RAID将无法满足需求。比如RAID5仅支持一个盘失败，即使是RAID5也仅支持两个盘失效，所以支持多个盘失效的算法也就是earsure code技术。</p>
<p>简而言之，erasure code是一个能够有效提升<strong><font color='red'>存储效率、安全性</font></strong>和<strong><font color='red'>便捷性</font></strong>的新兴存储技术。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>【学术定义】：将n份原始数据，增加m份数据（用来存储erasure编码），并能通过n+m份中的任意n份数据还原为原始数据。</p>
<p>定义中包含了<strong>encode</strong>和<strong>decode</strong>两个过程：</p>
<ul>
<li>首先将原始的n份数据变为n+m份（encode）;</li>
<li>之后这n+m份数据可存放在不同的device上，如果有任意小于m份的数据失效，仍然能够通过剩下的数据进行还原【也就是说，通常n+m的erasure编码，能够容许m块数据障碍。这时候的存储成本是1+m/n，通常m&lt;n】；</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>Erasure Code的使用场景</strong></p>
<blockquote>
<p>凡是需要通过冗余来进行高可用的场景。</p>
<p>但是总体而言，主要运用于存储和数字编码领域；</p>
<ul>
<li>阵列：如果磁盘阵列需要使用高级特性，比如需要能够容错两个磁盘失效（RAID6），那么可以用n+2的模式；如果想容错4个磁盘失效，则可使用n+4的模式。</li>
<li>云存储：erasure code是云存储的核心技术，最初诸如hadoop，GFS，CEPH等都在用n-way replication来处理冗余，但会有极大的成本开销，因此erasure code上台。</li>
<li>P2P领域</li>
<li>数字编码</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/sinat_27186785/article/details/52034588">https://blog.csdn.net/sinat_27186785/article/details/52034588</a></li>
<li><a href="https://blog.csdn.net/shelldon/article/details/54144730">https://blog.csdn.net/shelldon/article/details/54144730</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Tail Latency</title>
    <url>/2021/10/21/20211021-Tail-Latency/</url>
    <content><![CDATA[<h3 id="尾部延迟Tail-Latency"><a href="#尾部延迟Tail-Latency" class="headerlink" title="尾部延迟Tail Latency"></a>尾部延迟Tail Latency</h3><p>广泛存在于高并发系统中。开发和运维高并发系统的时候，会出现：明明系统已经调优完毕，该异步的异步，该减少互斥的地方引入无锁，该减少的IO的地方更换引擎或者硬件，该调节内核的调节相应参数。</p>
<p>然而如果在系统中引入实时监控，总会<strong>有少量响应的延迟高于均值</strong>，我们把这些响应称为尾延迟（Tail Latency）。<strong>对于大规模分布式系统而言，尾延迟的影响尤其严重，例如大规模搜索引擎，单个请求可能就会发送到上万台服务器，系统不得不等待尾延迟响应之后才能返回给用户。</strong></p>
<p>尾延迟可能是程序设计本身导致的毛病。但是及时程序设计完全无误，尾延迟依然可能存在。实际上，硬件、操作系统本身，都可能导致尾延迟响应，例如：主机系统其他进程的影响，应用程序中的线程调度、CPU功耗设计等。</p>
]]></content>
  </entry>
  <entry>
    <title>What does Recilience exactly means in System Building</title>
    <url>/2021/10/21/20211021-What-does-Recilience-exactly-means-in-System-Building/</url>
    <content><![CDATA[<blockquote>
<p><strong>引入</strong>：在大量的论文中，都讨论了系统构建的韧性(Service Resilience)。感觉不是很能理解韧性的含义，感觉有点像容错性，但是又不完全是fault-tolerance，所以进行了调研。</p>
</blockquote>
<span id="more"></span>
<ul>
<li><p><strong>Service Resilience的含义</strong></p>
<blockquote>
<p>Service Resilience是指当服务的运行环境出了问题，例如网络故障、服务过载或微服务宕机的情况下，程序仍然能够提供部分或者大部分服务，这时我们就说服务的<strong>韧性</strong>very good。Serive Resilience在微服务体系中非常重要，它通过提高服务的韧性来弥补环境上的不足。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>Service Resilience具体方法</strong></p>
<blockquote>
<p>具体而言，通过服务超时timeout、服务重试retry、服务限流rate limiting、熔断器circuit breaker、故障注入fault injection、舱壁隔离技术bulkhead</p>
</blockquote>
</li>
</ul>
<p><strong><font color='cornflowerblue'>简而言之，resilience可以理解为：当出现一些干扰性事件时，系统保持其关键服务继续正常运行的可能性。</font></strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/81111394">https://zhuanlan.zhihu.com/p/81111394</a></li>
<li><a href="https://blog.csdn.net/weixin_45882672/article/details/117531867">https://blog.csdn.net/weixin_45882672/article/details/117531867</a></li>
<li><a href="https://blog.csdn.net/devopscsdn/article/details/89515885?utm_term=%E8%BD%AF%E4%BB%B6%E7%9A%84resilience&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-4-89515885&amp;spm=3001.4430">https://blog.csdn.net/devopscsdn/article/details/89515885?utm_term=%E8%BD%AF%E4%BB%B6%E7%9A%84resilience&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-4-89515885&amp;spm=3001.4430</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>What is Serverless Computing?</title>
    <url>/2021/10/23/20211023-What-is-Serverless-Computing/</url>
    <content><![CDATA[<p>Serverless Computing：无线服务器</p>
<p>Serverless优势：</p>
<ul>
<li>可用性冗余，以便单个机器故障不会导致服务中断；</li>
<li>冗余副本的地理分布，以便在发生灾难时保留服务；</li>
<li>负载平衡和请求路由以有效利用资源；</li>
<li>相应负载变化进行自动缩放以扩展或缩小系统；</li>
<li>监控以记录调试或性能调整所需的信息；</li>
<li>系统升级，包括安全修补；</li>
<li>迁移到新实例时可用；</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.alibabacloud.com/zh/knowledge/what-is-serverless">https://www.alibabacloud.com/zh/knowledge/what-is-serverless</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Import TLE data into STK</title>
    <url>/2021/10/29/20211029-Import-TLE-data-into-STK/</url>
    <content><![CDATA[<h3 id="Matlab函数说明"><a href="#Matlab函数说明" class="headerlink" title="Matlab函数说明"></a>Matlab函数说明</h3><ul>
<li>lla2ecef: Convert geodetic coordinates to Earth-centered Earth-fixed coordinates</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://blog.csdn.net/caijibai/article/details/120176707">用STK导入段时间TLE数据</a></li>
<li>STK学习资料：<a href="https://blog.csdn.net/stk10/category_1364277.html">https://blog.csdn.net/stk10/category_1364277.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Django-1.概论和python语法</title>
    <url>/2021/10/31/20211031-Django-1-%E6%A6%82%E8%AE%BA%E5%92%8Cpython%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>Django使用Python创建的，Youtube、Instagram；</li>
<li>可以作为Web、APP、小程序等各种程序的后端；</li>
<li>项目运行瓶颈：数据库查询、网络带宽/延迟、硬盘读写速度等；</li>
<li>计算密集型的模块使用可以用C/C++实现，然后编译成动态链接库再import进来；</li>
<li>计算密集型的微服务可以通过thift等工具对接，微服务的Server端代码可以用C/C++语言实现；</li>
</ul>
<span id="more"></span>
<ul>
<li><strong>数据库（服务器端）</strong><ul>
<li>disk：本地、<strong>云盘</strong>；</li>
<li>mysql：代码文本等；</li>
<li>Redis：属于内存数据库，用来存储数据（内存中的map）</li>
</ul>
</li>
<li><p><strong>数据库（客户端）</strong></p>
<ul>
<li>web storage</li>
<li>disk内存</li>
</ul>
</li>
<li><p><strong>深拷贝和浅拷贝</strong></p>
<blockquote>
<ul>
<li><p><strong>浅拷贝：【1‘43’22】</strong>b=a[:]，把a的第一层复制过去；之后改变b，a不会发生改变</p>
</li>
<li><p><strong>深拷贝：</strong>递归深度遍历复制，无论b如何改变a都不会改变</p>
</li>
<li><p>示例：</p>
<ul>
<li><p>浅拷贝</p>
<p><img src="/images/doc/7.png" alt="image-20211101102326919" style="zoom:67%;" /></p>
<p><code>c[3][0] = 9; c[1]=0;</code></p>
<p><img src="/images/doc/8.png" alt="image-20211101102429643" style="zoom:67%;" /></p>
<p>可以看到，浅拷贝可以改变的元素只有第1层；</p>
</li>
<li><p>深拷贝     <code>import copy</code></p>
<p><img src="/images/doc/9.png" alt="image-20211101102651638" style="zoom:67%;" /></p>
<p><code>c[3][3][0] = 100;</code></p>
<p><img src="/images/doc/10.png" alt="image-20211101102750906" style="zoom:67%;" /></p>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>解放数组*，解放dict</strong>：**</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">a,b,c,d</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a,b,c,d)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">g(*a)	<span class="comment"># 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">b = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>:<span class="number">5</span>&#125;</span><br><span class="line">g(**b)	<span class="comment"># 2 3 4 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>lambda表达式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">g = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line">f(<span class="number">3</span>, <span class="number">4</span>)	<span class="comment">#7</span></span><br><span class="line">g(<span class="number">3</span>, <span class="number">4</span>)	<span class="comment">#7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>元组在定义的时候可以省略小括号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = (1, 2, 3)</span><br><span class="line">b = 1, 2, 3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对应元素zip</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="built_in">print</span>(a[i], b[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b):</span><br><span class="line">    <span class="built_in">print</span>(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 a</span></span><br><span class="line"><span class="comment"># 2 b</span></span><br><span class="line"><span class="comment"># 3 c</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>with可以增加文件操作的鲁棒性；</p>
</li>
<li><p>static静态变量：所有对象公用该变量；</p>
</li>
<li><p>所有的成员函数都需要self；</p>
</li>
</ul>
<h3 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h3><ul>
<li><a href="https://docs.python.org/zh-cn/3/">https://docs.python.org/zh-cn/3/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Django-2-Git&amp;Docker部署</title>
    <url>/2021/10/31/20211031-Django-2-Git-Docker%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="服务器用户分配"><a href="#服务器用户分配" class="headerlink" title="服务器用户分配"></a>服务器用户分配</h3><p> 安装参考链接：见参考文档《2. 配置docker、git环境与项目创建》。</p>
<p><img src="/images/doc/5.png" alt="image-20211101171619017" style="zoom:80%;" /></p>
<span id="more"></span>
<blockquote>
<p>Host server1</p>
<p>​    HostName: 公网IP 139.224.111.142</p>
<p>​    UserName: kunkun</p>
</blockquote>
<h3 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h3><p> <img src="/images/doc/6.png" alt="image-20211101180949177" style="zoom: 80%;" /></p>
<h3 id="Django镜像"><a href="#Django镜像" class="headerlink" title="Django镜像"></a>Django镜像</h3><blockquote>
<ul>
<li>ssh server1</li>
<li>ssh kunkun@localhost -p 20000 【ssh登录端口】</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Orbit Phasing</title>
    <url>/2021/11/02/20211102-Orbit-Phasing/</url>
    <content><![CDATA[<h1 id="Orbit-phasing"><a href="#Orbit-phasing" class="headerlink" title="Orbit phasing"></a>Orbit phasing</h1><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Orbit_phasing">https://en.wikipedia.org/wiki/Orbit_phasing</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>RAAN</title>
    <url>/2021/11/02/20211102-RAAN/</url>
    <content><![CDATA[<h3 id="RAAN-Right-Ascension-of-the-Ascending-Node"><a href="#RAAN-Right-Ascension-of-the-Ascending-Node" class="headerlink" title="RAAN: Right Ascension of the Ascending Node"></a>RAAN: Right Ascension of the Ascending Node</h3><ul>
<li><p>理解：实际上是发射到轨道升交点的，也就是Y界面画云的时候轨道上的小白点。太阳帆很多时候一射上去就会急转弯，从垂直于轨道变成沿着轨道运行。</p>
<blockquote>
<p><strong><a href="https://www.bilibili.com/video/BV1C64y1D7bq?from=search&amp;seid=18189804865902236483&amp;spm_id_from=333.337.0.0">Demo</a>：</strong></p>
<p><img src="/images/doc/4.png" alt="image-20211102201116589" style="zoom:50%;" /></p>
</blockquote>
</li>
<li><p>RAAN是轨道与黄道面的交点，一个升交，一个降交，幅角则是在黄道面上的方位角</p>
</li>
<li><p>黄道面：地球绕太阳运行的轨道所在的平面。任何不与黄道面共面的天体或者人造物轨道都会和黄道面相交2次，由南向北的叫做升交点，由北向南的叫降交点；</p>
</li>
<li><p>黄道面：赤道所在的平面是赤道面；</p>
<p> <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.leleketang.com%2Fres%2Fquestion%2Fpic%2F15296%2Foen00015249.jpg&amp;refer=http%3A%2F%2Fwww.leleketang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1638448417&amp;t=d13cd5b3cbd16d885717cf6aa581eb5c" alt="img" style="zoom:80%;" /></p>
</li>
<li><p>升交点黄经（Longitude of the ascending node）</p>
</li>
<li>北大西洋自治区</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node">https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node</a></li>
<li><a href="https://baike.baidu.com/item/%E5%8D%87%E4%BA%A4%E7%82%B9%E7%BB%8F%E5%BA%A6/5908738">https://baike.baidu.com/item/%E5%8D%87%E4%BA%A4%E7%82%B9%E7%BB%8F%E5%BA%A6/5908738</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>STK-1-propagator</title>
    <url>/2021/11/02/20211102-STK-1-propagator/</url>
    <content><![CDATA[<h1 id="STK-Propagator-轨道预报模型"><a href="#STK-Propagator-轨道预报模型" class="headerlink" title="STK-Propagator 轨道预报模型"></a>STK-Propagator 轨道预报模型</h1><ul>
<li>STK提供了2种形式的<font color='red'><strong>卫星轨道预报算法</strong></font>：<ul>
<li>解析算法：通过求解卫星运动的微分方程得到一个近似解析解来获得卫星星历表，或直接给出卫星在各个特定时刻的位置和速度信息；</li>
<li>数值算法：过对卫星运动方程的数值积分来实现的．STK中所有标准的算法均为解析法．</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul>
<li>STK中提供的<font color='red'><strong>轨道预报模型</strong></font>包括：<ul>
<li>TwoBody：二体模型，又叫开普勒运动模型，它只考虑地球对卫星的引力，此时地球等效为一个质点</li>
<li>J2 Perturbation：J2 Perturbation一阶模型考虑了因地球的非正球体中J2系数导致的卫星轨道要素的长期变化．J2是地球非球形引力值无穷级数表达式中的一个带谐项系数，此系数代表了地球非正球体所带来的最重要的效应．在该模型中J2系数是唯一导致卫星轨道要素发生长期变化的因素．J2摄动算法就包括了J2参数所带来的一阶长期效应．</li>
<li>J4 Perturbation：J4 Perturbation二阶模型同样考虑地球的非正球体导致的卫星轨道要素的长期变化，与J2 Perturbation不同的是它不仅考虑J2系数的一阶效应，还考虑了J4系数所代表的偶次带谐项对轨道参数的影响(没考虑代表长周期效应的J3系数)．J4系数代表的地球非正球体引力摄动大概比J2系数要小1000倍，所以，这两种预报模型得出的卫星轨道差别很小．</li>
<li>HPOP(The High-precision orbit propagator)：高精度轨道预报模型，可以用来处理轨道高度从地球表面到月球表面甚至更远的任何圆形、椭圆、抛物线和双曲线轨道．这种模型在某一历元下生成卫星轨道时所需设置的参数与二体模型、J2模型和J4模型是相同的．</li>
<li>MSGP4(The Merged Simplified General Perturbations)：MSGP4模型是一个符合北美防空司令部标准的预报算法模型．该模型全面考虑了地球的非正球体、日月引力以及引力谐振因素带来的长期和周期效应，并使用了一个简单的大气模型来考虑轨道衰减的问题．</li>
<li>LOP(The Long—term orbit propagator)：长期轨道预报模型，可以获得较长时间间隔，如数月甚至几年内的高精度轨道预报数据．LOP和二体、J2和J4模型使用相同的轨道设置参数．</li>
<li>StkExtemal：能够从一个带有．e扩展名的文件读取一个卫星的星历表．</li>
<li>PODS(Precision Orbit Determination Systern)：精确定轨系统，PODS可根据提供的卫星跟踪数据确定相应的卫星轨道和参数，其中处理的卫星跟踪数据包括由地面站、TPRSS和GPS提供的各种精度、距离、星间距离和位置等信息．</li>
<li>SPICE(Spacecraft Planet Instrument C—Matrix and Event)：可以从SPICE工具包里引入一个星历表文件．</li>
<li>Astrogator：利用该模型可动态显示卫星轨道机动等情况．</li>
<li>Real Time：该模型可引入实时数据以实时更新轨道．</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>STK-2-stkSetPropClassical</title>
    <url>/2021/11/02/20211102-STK-2-stkSetPropClassical/</url>
    <content><![CDATA[<p>create_LEO.m：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">stkSetPropClassical(sat_no,<span class="string">&#x27;J4Perturbation&#x27;</span>,<span class="string">&#x27;J2000&#x27;</span>,<span class="number">0.0</span>,tStop,dT,<span class="number">0</span>,<span class="number">6371000</span> + Altitude * <span class="number">10</span>^<span class="number">3</span>,<span class="number">0.0</span>,inc,<span class="number">0.0</span>,ra,ma);</span><br><span class="line"><span class="comment">% &#x27;J4Perturbation&#x27;: 表示该卫星运动使用的力学模型</span></span><br><span class="line"><span class="comment">% &#x27;J2000&#x27;: 卫星使用的坐标系</span></span><br><span class="line"><span class="comment">% &#x27;6371000 + Altitude * 10^3&#x27;: 轨道高度（包括了地球半径）</span></span><br><span class="line"><span class="comment">% &#x27;ra&#x27;: 轨道的RAAN（right ascension of the ascending node）值</span></span><br><span class="line"><span class="comment">% &#x27;ma&#x27;: 轨道的平近点角（mean anomaly） ，它确定了卫星在轨道上的位置</span></span><br><span class="line"><span class="comment">% Inc的范围是0°~90°，raan的范围是0°~180°，mean anomaly的范围是0°~360°</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>查找资料：</p>
<p><img src="/images/doc/3.png" alt="image-20211102221622171" style="zoom:80%;" /></p>
<p> <img src="/images/doc/2.png" alt="image-20211102215108648" style="zoom:80%;" /></p>
<p><img src="/images/doc/1.png" alt="image-20211102223038446" style="zoom: 67%;" /></p>
]]></content>
  </entry>
  <entry>
    <title>Walker Constellation</title>
    <url>/2021/11/02/20211102-Walker-Constellation/</url>
    <content><![CDATA[<h3 id="卫星星座设计"><a href="#卫星星座设计" class="headerlink" title="卫星星座设计"></a>卫星星座设计</h3><p>卫星星座设计经常被误解为仅仅是在修改后的轨道上复制单个卫星的多个副本的行为。卫星星座设计过程有点类似于开发多细胞生物，每个细胞代表一个卫星。</p>
<p><font color='orange'><strong><u>开普勒轨道参数（6个）</u></strong></font>的无限选择使星座设计异常困难。提出了各种星座几何结构来降低这种复杂性。最著名的星座几何是约翰·沃克 (John Walker) 在 1970 年提出的沃克-德尔塔星座。沃克的几何使轨道参数以一种特定的方式相互依赖，从而降低了复杂性。</p>
<p>Walker-Delta 技术提供了所有星座设计技术中最对称的几何形状。因此，它最适合与地球观测相关的几种应用的全球覆盖。</p>
<span id="more"></span>
<p>具体而言，设计卫星星座是没有明确的规则的，其中卫星星座的参数定义是和任务紧密联系的，即“任务驱动”的。通常星座中的所有卫星都具有相似的高度分布、偏心率和倾角，因此外来扰动对每个卫星的影响而言通常是相似的。其中设计卫星星座时主要需要以下因素：</p>
<ul>
<li>卫星数量：影响覆盖范围和成本估计；</li>
<li>轨道平面数量：根据需求调整。由于轨道之间转移会增加发射和转移成本，因此具有最少数量的轨道平面最佳；</li>
<li>最小仰角：所有卫星必须保持一致，从而保证单个卫星的覆盖范围；</li>
<li>高度：会影响覆盖范围、转移成本。</li>
<li>倾角：确定覆盖的维度分布并根据覆盖需求进行选择。</li>
<li>平面间距：均匀的平面间距导致连续的地面覆盖；</li>
<li>偏心率：当我们需要卫星在特定区域停留更长时间时，倾向于选择椭圆轨道。</li>
</ul>
<h3 id="常见设计星座几何结构"><a href="#常见设计星座几何结构" class="headerlink" title="常见设计星座几何结构"></a>常见设计星座几何结构</h3><ul>
<li><p><strong>A class of circular orbit geometries:</strong> <u><font color='red'><strong>Walker Delta Pattern constellation  |  Ballard rosette</strong></font></u>[proposed by John Walker], and its notation is: i: t/p/f</p>
<blockquote>
<ul>
<li><font color='cornflowerblue'><strong>i:</strong></font> inclination</li>
<li><font color='cornflowerblue'><strong>t:</strong></font> total number of satellites</li>
<li><font color='cornflowerblue'><strong>p:</strong></font> number of equally spaced planes</li>
<li><font color='cornflowerblue'><strong>f:</strong></font> relative spacing between satellites in adjcent planes. f*360/t</li>
</ul>
</blockquote>
</li>
<li><p>An example: the Galileo Navigation system—— Walker Delta 56°:24/3/1</p>
<blockquote>
<p>24 satellites in 3 planes inclined at 56 degrees</p>
<p>The “1” defines the phasing between the planes, and how they are spaced. </p>
<p>Demo: <a href="https://www.youtube.com/watch?v=w1eb37tOei4">https://www.youtube.com/watch?v=w1eb37tOei4</a></p>
</blockquote>
</li>
<li><p>Ballard rosette, its notation is: (t,p,m) </p>
<blockquote>
<ul>
<li><font color='cornflowerblue'><strong>m: </strong></font>multiple of the fractional offset between planes.</li>
</ul>
</blockquote>
</li>
<li><p>the near-polar Walker Star</p>
</li>
</ul>
<h3 id="倾斜圆轨道星座"><a href="#倾斜圆轨道星座" class="headerlink" title="倾斜圆轨道星座"></a>倾斜圆轨道星座</h3><ul>
<li><p>Walker Star极轨道星座卫星网络</p>
<p>  <img src="https://img-blog.csdnimg.cn/20201020121157211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FubmUwMzM=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom: 67%;" /></p>
</li>
<li><p>Walker Delta倾斜星座卫星网络</p>
<p> <img src="https://img-blog.csdnimg.cn/20201020121243342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FubmUwMzM=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:67%;" /></p>
</li>
<li><p>Ballard Rosette星座</p>
<p> <img src="https://img-blog.csdnimg.cn/20201020121318174.png#pic_center" alt="在这里插入图片描述" style="zoom:67%;" /></p>
</li>
</ul>
<ul>
<li>太空时代始于1957年10月的Sputnik-1 </li>
<li><strong>Satellite Constellation:</strong> a group of artificial satellite</li>
<li><strong>Orbital Shells:</strong> the sets of circular orbits at constant altitude</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li>具体理论和介绍参见：<a href="https://en.wikipedia.org/wiki/Satellite_constellation">https://en.wikipedia.org/wiki/Satellite_constellation</a></li>
<li><a href="https://astrome.net/blogs/the-art-of-satellite-constellation-design-what-you-need-to-know/">https://astrome.net/blogs/the-art-of-satellite-constellation-design-what-you-need-to-know/</a></li>
<li><a href="http://www.jos.org.cn/html/2014/5/4581.htm#outline_anchor_17">http://www.jos.org.cn/html/2014/5/4581.htm#outline_anchor_17</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>地理名词中英文对照</title>
    <url>/2021/11/02/20211102-%E5%9C%B0%E7%90%86%E5%90%8D%E8%AF%8D%E4%B8%AD%E8%8B%B1%E6%96%87%E5%AF%B9%E7%85%A7/</url>
    <content><![CDATA[<h1 id="地理名词中英文对照"><a href="#地理名词中英文对照" class="headerlink" title="地理名词中英文对照"></a>地理名词中英文对照</h1><ul>
<li><font color='orange'><strong>RAAN:</strong> </font>the right ascension of the ascending node 升交点黄经</li>
<li><font color='orange'><strong>春分点:</strong> </font>the first point of aries</li>
<li><p><font color='orange'><strong>LTAN:</strong> </font>local time of the ascending node</p>
</li>
<li><p><font color='orange'><strong>heliocentric orbits:</strong></font>日心轨道</p>
</li>
<li><p><font color='orange'><strong>ecliptic:</strong></font>黄道</p>
</li>
<li><p><font color='orange'><strong>celestial sphere:</strong></font>天球</p>
</li>
<li><p><font color='orange'><strong>perpendicular projection:</strong></font>垂直射影</p>
</li>
<li><p><font color='orange'><strong>True anomaly</strong></font>：真近点角 <a href="https://en.wikipedia.org/wiki/True_anomaly">https://en.wikipedia.org/wiki/True_anomaly</a></p>
</li>
<li><p><font color='orange'><strong>Eccentric anomaly</strong></font>：偏近点角 <a href="https://en.wikipedia.org/wiki/Eccentric_anomaly">https://en.wikipedia.org/wiki/Eccentric_anomaly</a></p>
</li>
<li><font color='cornflowerblue'>2 * semi-major-axis == apoapsis(远地点) + periapsis(近地点)</font>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>STK-3-CBF(Central Body Fixed Frame)</title>
    <url>/2021/11/03/20211103-STK-3-CBF-Central-Body-Fixed-Frame/</url>
    <content><![CDATA[<h3 id="CBF中心体坐标系-Central-Body-Fixed-Frame"><a href="#CBF中心体坐标系-Central-Body-Fixed-Frame" class="headerlink" title="CBF中心体坐标系(Central Body Fixed Frame)"></a>CBF中心体坐标系(Central Body Fixed Frame)</h3><p>视线约束主要是考虑信号传播路径中地面障碍物的影响。</p>
<p>大地通常被视为一个椭圆体，在中心体坐标系（central body frame）中认为该椭圆体的形状是固定的。在椭圆体模型中，地面认为是局部平坦的（不考虑高山、丘陵、山谷等），地面模型非常简单。对地面进行更精确的建模需要AzEI蒙版或者地形蒙版工具，采用不同的访问约束（Access Constraints）来建模。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/63365900">https://zhuanlan.zhihu.com/p/63365900</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Python-1-geopy.distance</title>
    <url>/2021/11/04/20211104-Python-1-geopy-distance/</url>
    <content><![CDATA[<h1 id="Geopy模块"><a href="#Geopy模块" class="headerlink" title="Geopy模块"></a>Geopy模块</h1><p>当我们需要计算A，B两点之间的最短距离时，可以使用geopy模块的distance.distance函数（可参见<a href="https://www.osgeo.cn/geopy/">官方文档说明</a>）。</p>
<p>Geopy可以用 <a href="https://en.wikipedia.org/wiki/Geodesics_on_an_ellipsoid">geodesic distance</a> 或 <a href="https://en.wikipedia.org/wiki/Great-circle_distance">great-circle distance</a> ，默认测地线距离作为函数 <code>geopy.distance.distance</code> .</p>
<p>大圆距离（ <a href="https://www.osgeo.cn/geopy/#geopy.distance.great_circle"><code>great_circle</code></a> ）使用地球的球形模型，使用国际大地测量学和地球物理学联合会定义的平均地球半径6371.0087714150598公里，约6371.009公里（WGS-84），误差高达0.5%。半径值存储在 <code>distance.EARTH_RADIUS</code> ，因此可以对其进行自定义（但是，它应该始终以公里为单位）。</p>
<span id="more"></span>
<p>具体而言，以下是以下示例 <code>distance.distance</code> 用法，取对 <code>(lat, lon)</code> 元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> geopy <span class="keyword">import</span> distance</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newport_ri = (<span class="number">41.49008</span>, -<span class="number">71.312796</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cleveland_oh = (<span class="number">41.499498</span>, -<span class="number">81.695391</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(distance.distance(newport_ri, cleveland_oh).miles)</span><br><span class="line"><span class="number">538.39044536</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wellington = (-<span class="number">41.32</span>, <span class="number">174.81</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>salamanca = (<span class="number">40.96</span>, -<span class="number">5.50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(distance.distance(wellington, salamanca).km)</span><br><span class="line"><span class="number">19959.6792674</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<blockquote>
<ul>
<li><p>目前所有的算法都假设点的高度要么为零（如上面的例子中所示）要么相等，并且相对较小。因此，海拔高度不会影响结果距离：</p>
</li>
<li><p>如果需要使用高程计算距离，则对于短距离 <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a> 公式可以给出一个合适的近似值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> geopy <span class="keyword">import</span> distance</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = (<span class="number">43.668613</span>, <span class="number">40.258916</span>, <span class="number">0.976</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2 = (<span class="number">43.658852</span>, <span class="number">40.250839</span>, <span class="number">1.475</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flat_distance = distance.distance(p1[:<span class="number">2</span>], p2[:<span class="number">2</span>]).km</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(flat_distance)</span><br><span class="line"><span class="number">1.265133525952866</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>euclidian_distance = math.sqrt(flat_distance**<span class="number">2</span> + (p2[<span class="number">2</span>] - p1[<span class="number">2</span>])**<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(euclidian_distance)</span><br><span class="line"><span class="number">1.359986705262199</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Django-3-网站开发操作记录</title>
    <url>/2021/11/13/20211113-Django-3-%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将镜像文件`django_lesson_1_0.tar`加载到本地</span></span><br><span class="line">docker load -i django_lesson_1_0.tar	</span><br><span class="line"></span><br><span class="line">docker images</span><br><span class="line"><span class="meta">#</span><span class="bash"> REPOSITORY      TAG       IMAGE ID       CREATED       SIZE</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> django_lesson   1.0       58e383d3fa92   2 weeks ago   1.5GB</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个docker可以有多个镜像，同一个镜像可以生成多个容器，相同镜像生成的容器环境都是完全一致的；</p>
<p>每一个容器可以视为一个独立的服务器；</p>
<p>对于文件管理，docker和git都采取了空间优化；</p>
]]></content>
  </entry>
  <entry>
    <title>20211217-NP问题</title>
    <url>/2021/12/17/20211217-NP%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="什么是P问题、NP问题、NPC问题、NP-hard问题？"><a href="#什么是P问题、NP问题、NPC问题、NP-hard问题？" class="headerlink" title="什么是P问题、NP问题、NPC问题、NP-hard问题？"></a>什么是P问题、NP问题、NPC问题、NP-hard问题？</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li>通常所谓的NP问题，实际上就是：证明或推翻P=NP；</li>
<li>NPC：只有搜才行；</li>
<li>时间复杂度：并非表示一个程序解决时间需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长多快；</li>
<li>不可解问题（Undecidable Decision Problem）：例如The Halting Problem；</li>
</ul>
<span id="more"></span>
<ul>
<li>P问题：如果一个问题可以找到一个能在多项式的时间里解决它的算法，该问题则属于P问题。我们通常见到的信息奥赛的题目都是P问题，因为一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法；</li>
<li><p>NP问题：找到一个比100小的解（全部找出来不容易，但是验证其中一个解是容易的）；</p>
<ul>
<li>定义1：可以在多项式的时间里验证一个解的问题（并不是非P问题）；</li>
<li>定义2：可以在多项式的时间里猜出一个解的问题；</li>
</ul>
</li>
<li>通常只有NP问题才可能找到多项式的算法，我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。</li>
<li>目前人们普遍认为P=NP问题不成立，即存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P!=NP的原因在于：NPC问题的存在，即NP-完全问题；</li>
<li><p>约化（Reducibility）：Hamilton回路问题可以约化为TSP问题；</p>
<ul>
<li>定义1：一个问题A可以约化为问题B，即可以用问题B的解法解决问题A，或称”问题A可以变成问题B“；</li>
<li>定义2：可以找到一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B 的输入，使两个程序的输出相同；</li>
<li>约化具有传递性；</li>
</ul>
</li>
<li><p>NPC问题：所有的NP问题都可以约化成它；</p>
<ul>
<li>定义：<ul>
<li>条件1：该问题是NP问题；</li>
<li>条件2：所有的NP问题都可以约化成它；</li>
</ul>
</li>
<li>证明：<ul>
<li>首先证明它至少是一个NP问题；</li>
<li>证明其中一个已知的NPC问题能约化到它；</li>
</ul>
</li>
<li>逻辑电路问题属于NPC问题，因为其显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，大致意思是：任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出，因此对于一个NP问题而言，问题转化为了求出满足结果为True的一个输入（即一个可行解）；</li>
<li>已被证明是NPC的问题：Hamilton回路、TSP问题；</li>
</ul>
</li>
<li>NP-hard问题：满足NPC问题的第二条，但是不一定要满足第一条。因此NP-hard问题有可能仍然无法得到多项式级别的算法。</li>
</ul>
<h4 id="2-推论"><a href="#2-推论" class="headerlink" title="2. 推论"></a>2. 推论</h4><ul>
<li>所有的P类问题都是NP问题：能多项式地解决一个问题，必然能多项式地验证一个问题的解；</li>
<li>所有的NP问题都能约化成NPC问题，因此只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决，即NP=P；</li>
</ul>
<h4 id="3-0-1背包问题是NP完全问题"><a href="#3-0-1背包问题是NP完全问题" class="headerlink" title="3. 0-1背包问题是NP完全问题"></a>3. 0-1背包问题是NP完全问题</h4>]]></content>
  </entry>
  <entry>
    <title>20211218-联邦学习</title>
    <url>/2021/12/18/20211218-%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="联邦学习-Federated-Learning"><a href="#联邦学习-Federated-Learning" class="headerlink" title="联邦学习(Federated Learning)"></a>联邦学习(Federated Learning)</h3><h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h4><p>在2016年由谷歌提出，原本用于解决安卓手机终端用户在本地更新模型的问题，设计目标是在保障大数据交换时的信息安全、保护终端数据和个人数据隐私、保证在合法前提下在多参与方或多计算节点之间展开高效率的及其学习。</p>
<p>联邦学习作为一种新型的人工智能基础技术，它可使用的机器学习算法不局限于神经网络，还包括随机森林等重要算法。联邦学习有望成为下一代人工智能协同算法和协作网络的基础。</p>
<h4 id="2-系统框架"><a href="#2-系统框架" class="headerlink" title="2. 系统框架"></a>2. 系统框架</h4><p>以下面的例子对联邦学习进行讲解。</p>
<span id="more"></span>
<p>假设企业 A 和 B 想联合训练一个机器学习模型，它们的业务系统分别拥有各自用户的相关数据。此外，企业 B 还拥有模型需要预测的标签数据。出于数据隐私保护和安全考虑，A 和 B 无法直接进行数据交换，可使用联邦学习系统建立模型。联邦学习系统构架由三部分构成，如图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20190427102223500.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhbzgxMjc1NTE1Ng==,size_16,color_FFFFFF,t_70" alt="example"></p>
<ul>
<li><p><font color='cornflowerblue'><strong>Part I：加密样本对齐。</strong></font>由于两家企业的用户群体并非完全重合，系统利用基于加密的用户样本对齐技术，在A和B不公开各自数据的前提下确认算双方的共有用户，并且不暴露不相互重叠的用户，以便联合这些用户的特征进行建模；</p>
</li>
<li><p><font color='cornflowerblue'><strong>PART II：加密训练模型。</strong></font>在确定共有用户群体后，就可以利用这些数据训练机器学习模型。为了保证训练过程中数据的保密性，需要借助第三方协作者C进行加密训练。以<strong>线性回归</strong>模型为例，训练过程如下：</p>
<ul>
<li>① 协作者C将公钥发送给A和B，用以对训练过程中需要交换的数据进行加密；</li>
<li>② A和B之间以加密形式交互用于计算梯度的中间结果；</li>
<li>③ A和B分别基于加密的梯度值进行计算，同时B根据其标签数据计算损失，并把结果汇总为C。C通过汇总结果计算总梯度值并将其解密；</li>
<li>④ C将解密后的梯度分别回传给A和B，A和B根据梯度更新各自模型的参数。</li>
</ul>
<p>迭代上述步骤直至损失函数收敛，这样就完成了整个训练过程。在样本对齐及模型训练过程中，A和B各自的数据均保留在本地，且训练中的数据交互也不会导致数据隐私泄露。因此双方在联邦学习的帮助下得以实现合作训练模型。</p>
</li>
<li><p><font color='cornflowerblue'><strong>PART III：效果激励。</strong></font>联邦学习的一大特点就是它解决了为什么不同机构要加入联邦共同建模的问题，即建立模型以后模型的效果会在实际应用中表现出来，并记录在永久数据记录机制（如区块链）上。提供数据多的机构所获得的模型效果会更好，模型效果取决于数据提供方对自己和他人的贡献。这些模型的效果在联邦机制上会分发给各个机构反馈，并继续激励更多机构加入这一数据联邦。</p>
</li>
</ul>
<p>上述三个部分，既考虑了多个机构间共同建模的隐私保护和效果，又考虑了一个共识机制奖励贡献数据多的机构。所以联邦学习是一个<strong>闭环</strong>的学习机制。</p>
<h4 id="3-联邦学习优势"><a href="#3-联邦学习优势" class="headerlink" title="3. 联邦学习优势"></a>3. 联邦学习优势</h4><p>联邦学习的优势有以下几点：</p>
<ul>
<li>数据隔离，数据不会泄漏到外部，满足用户隐私保护和数据安全的需求；</li>
<li>能够保证模型质量无损，不会出现负迁移，保证联邦模型比割裂的独立模型效果好；</li>
<li>参与者地位对等，能够实现公平合作；</li>
<li>能够帮保证参与各方在保持独立性的情况下，进行信息与模型参数的加密交换，并同时获得时长；</li>
</ul>
<h4 id="4-联邦学习分类"><a href="#4-联邦学习分类" class="headerlink" title="4. 联邦学习分类"></a>4. 联邦学习分类</h4><p>针对不同数据集，联邦学习分为横向联邦学习、纵向联邦学习、联邦迁移学习。</p>
<ul>
<li><p>横向联邦学习：两个数据集的用户特征重叠较多，而用户重叠较少。此时我们将数据集按照横向（即用户维度）切分，并取出双方用户特征相同而用户不完全相同的那部分数据进行训练。</p>
<blockquote>
<p>举例：两家不同地区的银行，它们的用户群体分别来自各自所在的地区，相互的交集很小。但是它们的业务很相似，因此记录的用户特征是相同的。此时我们就可以使用横向联邦学习来构建联合模型。</p>
<p>谷歌在2016年提出了一个针对安卓手机模型更新的数据联合建模方案：在单个用户使用安卓手机时，不断在本地更新模型参数并将参数上传到安卓云上，从而使特征维度相同的各数据拥有方建立联合模型。</p>
</blockquote>
</li>
<li><p>纵向联邦学习：两个数据集的用户重叠较多，而用户特征重叠较少。此时我们将数据集按照纵向（即特征维度）切分，并取出双方用户相同而用户特征不完全相同的那部分数据进行训练。</p>
<blockquote>
<p>举例：两个不同的机构，家是某地的银行，另一家是同一个地方的电商。它们的用户群体很有可能包含该地的大部分居民因此用户的交集较大。但是由于银行记录的都是用户的收支行为与信用评级，而电商则保有用户的浏览与购买历史，因此它们的用户特征交集较小。</p>
<p>纵向联邦学习就是将这些不同特征在加密的状态下加以聚合，以增强模型能力。目前，逻辑回归模型、树形结构模型和神经网络模型等众多机器学习模型已经逐渐被证实能够建立在此联邦体系上。</p>
</blockquote>
</li>
<li><p>联邦迁移学习：两个数据集的用户和用户特征重叠都较少，此时我们不对数据进行切分，而利用迁移学习来克服数据或标签不足的情况。</p>
<blockquote>
<p>举例：比如有两个不同机构，一家是位于中国的银行，另一家是位于美国的电商。由于受地域限制，这两家机构的用户群体交集很小。同时由于机构类型不同，二者的数据特征也只有小部分重合。此时要想进行有效的联邦学习，就必须引入迁移学习，来解决单边数据规模小和标签样本少的问题，从而提升模型的效果。</p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20211219-集成学习</title>
    <url>/2021/12/19/20211219-%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="集成学习-Ensemble-Learning"><a href="#集成学习-Ensemble-Learning" class="headerlink" title="集成学习 (Ensemble Learning)"></a>集成学习 (Ensemble Learning)</h3><p>集成学习本身并不是一个单独的机器学习算法，而是通过<font color='cornflowerblue'><strong>“博采众长”</strong></font>，即构建并结合多个机器学习器来完成学习任务。集成学习可用于：分类问题集成、回归问题集成、特征选取继承、异常点检测集成等任务。</p>
<span id="more"></span>
<h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>集成学习：对于给定的训练集，通过训练<strong>若干个个体学习器</strong>，通过<strong>特定的结合策略</strong>，最终形成一个强学习器。其中关键的问题：</p>
<ul>
<li><p>如何得到若干个个体学习器；</p>
<blockquote>
<ul>
<li><p>“三个臭皮匠，顶个诸葛亮”。集成学习实际上大多是针对<strong>弱学习器(weak learner)</strong>，即指泛化性能略优于随机猜测的学习器（如二分类问题中精度略高于50%的分类器）。</p>
</li>
<li><p><strong>集成学习如何保证整体效果优于最好的学习器单独工作的效果？</strong></p>
<blockquote>
<p>个体学习器应该“好而不同”，即个体学习器要有一定的准确性，学习器既不能太差，且需要具有多样性。</p>
</blockquote>
</li>
<li><p>根据个体学习器生成方式的不同，可<strong>将集成学习方法大致分为两类</strong>：</p>
<blockquote>
<ul>
<li>个体学习器之间<strong>存在强依赖关系</strong>，一系列学习器基本都需要串行生成的序列化方法，代表算法：<font color='red'><strong>boosting系列算法</strong></font>；</li>
<li>个体学习器之间<strong>不存在强依赖关系</strong>，一系列学习器可以并行生成，代表算法：<font color='red'><strong>bagging和随机森林(Random Forest)系列算法</strong></font>；</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>如何选择一种结合策略，将这些个体学习器集合成一个强学习器。</p>
<blockquote>
<p>平均法、投票法、学习法</p>
</blockquote>
</li>
</ul>
<p>  <img src="https://pic1.zhimg.com/v2-9c8976f361643d26f5304b3664e80bc4_b.jpg" alt="1"></p>
<h4 id="2-个体学习器"><a href="#2-个体学习器" class="headerlink" title="2. 个体学习器"></a>2. 个体学习器</h4><p>对既有的个体学习器，可以分成两种情况：</p>
<ul>
<li><p>同质(homogeneous)集成：所有个体学习器均是同一种类的。同质集成中的个体学习器也称为为“基学习器”(base learner)，相应的算法成为“基学习算法”。</p>
<blockquote>
<p>举例：均为决策树个体学习器、或者都是神经网络个体学习器；</p>
</blockquote>
</li>
<li><p>异质(heterogeneous)集成：所有的个体学习器不全是一个种类的。异质集成中的个体学习器称为“组件学习器”(component learner)或“个体学习器”。</p>
<blockquote>
<p>举例：现有一个分类问题，对训练集采用支持向量机个体学习器，逻辑回归个体学习器和朴素贝叶斯个体学习器来学习，再通过某种结合策略来确定最终的分类强学习器。</p>
</blockquote>
</li>
</ul>
<h4 id="3-Boosting"><a href="#3-Boosting" class="headerlink" title="3. Boosting"></a>3. Boosting</h4><ul>
<li><p><strong>Boosting算法的工作机制</strong></p>
<blockquote>
<p>首先从训练集用初始权重训练出一个弱学习器1，根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器1学习误差率高的训练样本点的权重变高，使得这些误差率高的点在后面的弱学习器2中得到更多的重视。然后基于调整权重后的训练集来训练弱学习器2.，如此重复进行，直到弱学习器数达到事先指定的数目T，最终将这T个弱学习器通过集合策略进行整合，得到最终的强学习器。</p>
<p><img src="https://pic3.zhimg.com/v2-2adde327b2b645738e2b57cb1946591a_b.jpg" alt="exp1"></p>
</blockquote>
</li>
<li><p><strong>经典的Boosting算法</strong></p>
<blockquote>
<ul>
<li>AdaBoost算法</li>
<li>提升树Boosting tree系列算法：应用最广泛的是梯度提升树(Gradient Boosting Tree)。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="4-Bagging"><a href="#4-Bagging" class="headerlink" title="4. Bagging"></a>4. Bagging</h4><ul>
<li><p><strong>Bagging算法的工作机制</strong></p>
<blockquote>
<p>不同于boosting算法，它的弱学习器之间没有依赖关系，可以并行生成。bagging的个体弱学习器的训练集是通过随机采样得到的。通过3次的随机采样，我们就可以得到3个采样集，对于这3个采样集，我们可以分别独立的训练出3个弱学习器，再对这3个弱学习器通过集合策略来得到最终的强学习器。</p>
<p><img src="https://pic1.zhimg.com/v2-005ff3ed31da676708b22c625af0fb90_b.jpg" alt="exp2"></p>
</blockquote>
</li>
<li><p>随机森林（Random Forest，简称RF）是Bagging的一个扩展变体。其在以决策树作为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。</p>
</li>
</ul>
<h4 id="5-Boosting和Bagging对比"><a href="#5-Boosting和Bagging对比" class="headerlink" title="5. Boosting和Bagging对比"></a>5. Boosting和Bagging对比</h4><div class="table-container">
<table>
<thead>
<tr>
<th>算法</th>
<th>Boosting</th>
<th>Bagging</th>
</tr>
</thead>
<tbody>
<tr>
<td>结构</td>
<td>串行</td>
<td>并行</td>
</tr>
<tr>
<td>训练集</td>
<td>依赖</td>
<td>独立</td>
</tr>
<tr>
<td>测试</td>
<td>需串行</td>
<td>可并行</td>
</tr>
<tr>
<td>作用</td>
<td>减小bias</td>
<td>减小variance</td>
</tr>
</tbody>
</table>
</div>
<h4 id="6-结合策略"><a href="#6-结合策略" class="headerlink" title="6. 结合策略"></a>6. 结合策略</h4><p>假设集成中包含 $T$ 个基学习器 $h_{1}, h_{2}, \ldots, h_{T}$，其中$h_i$在示例 $X$上的输出为 $h_i(x)$。那么对 $h_i$ 进行结合的常见策略有以下几种：</p>
<ul>
<li><p><strong>平均法</strong></p>
<blockquote>
<p>对于<font color='orange'><strong>数值类的回归预测问题</strong></font>，通常使用的结合策略是<strong>平均法</strong>。</p>
<ul>
<li>算术平均：$H(x)=\frac{1}{T} \sum_{1}^{T} h_{i}(x)$</li>
<li>加权平均：$H(x)=\sum_{1}^{T} w_{i} h_{i}(x)$，其中 $w_i$是个体学习器 $h_i$的权重</li>
<li>个体学习器的性能相差较大时用加权平均法，个体学习器性能相近时用简单平均法。</li>
</ul>
</blockquote>
</li>
<li><p><strong>投票法</strong></p>
<blockquote>
<p>对于<font color='orange'><strong>分类问题的预测</strong></font>，通常使用的结合策略是<strong>投票法</strong>。</p>
<ul>
<li>相对多数投票法(Plurality Voting)：即“少数服从多数”，即在$T$个弱学习器的对样本 $x$的预测结果中，数量最多的类别$c_i$为最终的分类类别。如果不止一个类别获得最高票，则随机选择一个做最终类别。</li>
<li>绝对多数投票法(Majority Voting)：即“票需过半数”。在相对多数投票法的基础上，不光要求获得最高票，还要求票过半数。否则会拒绝预测。</li>
<li>加权投票法(Weighted Voting)：和加权平均法一样，每个弱学习器的分类票数要乘以一个权重，最终将各个类别的加权票数求和，最大的值对应的类别为最终类别。</li>
</ul>
</blockquote>
</li>
<li><p><strong>学习法</strong></p>
<blockquote>
<p>平均法和投票法思路简单，但是学习误差可能较大，于是产生了<strong>学习法</strong>。<strong>代表方法是stacking</strong>。当使用stacking的结合策略时， 我们不是对弱学习器的结果做简单的逻辑处理，而是再加上一层学习器，也就是说，我们将训练集弱学习器的学习结果作为输入，将训练集的输出作为输出，重新训练一个学习器来得到最终结果。</p>
<p>在这种情况下，我们将弱学习器称为<strong>初级学习器</strong>，将用于结合的学习器称为<strong>次级学习器</strong>。对于测试集，我们首先用初级学习器预测一次，得到次级学习器的输入样本，再用次级学习器预测一次，得到最终的预测结果。</p>
<p>Stacking 就像是 Bagging的升级版，Bagging中的融合各个基础分类器是相同权重，而Stacking中则不同,Stacking中第二层学习的过程就是为了寻找合适的权重或者合适的组合方式。</p>
</blockquote>
</li>
</ul>
<h4 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h4><ul>
<li><a href="https://zhuanlan.zhihu.com/p/39920405">集成学习-Boosting,Bagging与Stacking</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20211220-Set Cover Problem</title>
    <url>/2021/12/20/20211220-Set-Cover-Problem/</url>
    <content><![CDATA[<p><strong>Weighted Set Cover (WSC)</strong>：带权集合覆盖问题</p>
<h3 id="Set-Cover-Problem"><a href="#Set-Cover-Problem" class="headerlink" title="Set Cover Problem"></a>Set Cover Problem</h3><p>研究这个问题，是因为看到论文中提及了Weighted Set Cover (WSC)，并论证该问题是NP-hard的。因此我希望了解什么是Weighted Set Cover。为了说明这个问题，我们首先需要知道<font color='cornflowerblue'><strong>集合覆盖(Set Cover)</strong></font>和<font color='cornflowerblue'><strong>顶点覆盖(Vertex Cover)</strong></font>的区别。</p>
<span id="more"></span>
<h4 id="1-集合覆盖-Set-Cover-和顶点覆盖-Vertex-Cover"><a href="#1-集合覆盖-Set-Cover-和顶点覆盖-Vertex-Cover" class="headerlink" title="1. 集合覆盖(Set Cover)和顶点覆盖(Vertex Cover)"></a>1. 集合覆盖(Set Cover)和顶点覆盖(Vertex Cover)</h4><h5 id="1-1-Set-Cover"><a href="#1-1-Set-Cover" class="headerlink" title="1.1 Set Cover"></a>1.1 Set Cover</h5><ul>
<li><strong>定义</strong></li>
<li>有包含了m个元素的集合A（注意，集合是无序的，并且包含的元素也是不相同的）。现有n个集合，分别为${B_1,B_2,…,B_n}$，这n个集合的并集恰好等于A集合，即: $A=B_{1} \cup B_{2} \cup B_{3} \cup \ldots \cup B_{n}$。<ul>
<li><strong>问题</strong>：是否存在B集合的最小子集，且他们的并集也等于A集合？</li>
<li><strong>举例</strong>：集合$A=\{1,2,3,4,5\}$，集合$B=\{\{1,2,3\},\{2,4\},\{3,4\},\{4,5\}\}$。可以看出，B集合的并集恰好等于A集合，那么问题的解是$SETCOVER=\{\{1,2,3\},\{4,5\}\}$。</li>
</ul>
</li>
</ul>
<h5 id="1-2-Vertex-Cover"><a href="#1-2-Vertex-Cover" class="headerlink" title="1.2 Vertex Cover"></a>1.2 Vertex Cover</h5><ul>
<li><p><strong>定义</strong></p>
<blockquote>
<p>有图G=(V, E)，是否存在V的子集V’，使得|V’|&lt;=|V|，并且G中的每条边e，至少有一个顶点在$|V^{‘}|$中？</p>
</blockquote>
</li>
<li><p>这个问题有一个NPO（No Optimization Problem）的变种，即：找到满足条件的最小顶点集，也就是使得满足条件下最小值$|V^{‘}|$。</p>
</li>
</ul>
<h5 id="1-3-二者比较"><a href="#1-3-二者比较" class="headerlink" title="1.3 二者比较"></a>1.3 二者比较</h5><ul>
<li>这是两类完全不同的问题，set cover属于集合一类问题，应用于计算机科学以及计算理论方面。vertex cover，属于图论一类问题，应用于计算机科学、计算理论、图论、数学等等方面。</li>
</ul>
<h4 id="2-集合覆盖-Set-Cover-的解决方案"><a href="#2-集合覆盖-Set-Cover-的解决方案" class="headerlink" title="2. 集合覆盖(Set Cover)的解决方案"></a>2. 集合覆盖(Set Cover)的解决方案</h4><p>现在我们希望对集合覆盖问题的解决方案进行说明。</p>
<h5 id="2-1-穷举法-exhausitive-search"><a href="#2-1-穷举法-exhausitive-search" class="headerlink" title="2.1 穷举法 exhausitive search"></a>2.1 穷举法 exhausitive search</h5><blockquote>
<p><strong>思想</strong>：首先遍历一遍单个子集，看看有无覆盖的。没有则再组合两个子集看有无全覆盖的。没有再组合三个子集……</p>
<p><strong>特点</strong>：暴力但简单</p>
</blockquote>
<h5 id="2-2-贪心算法-greedy-search"><a href="#2-2-贪心算法-greedy-search" class="headerlink" title="2.2 贪心算法 greedy search"></a>2.2 贪心算法 greedy search</h5><blockquote>
<p><strong>思想</strong>：循环直到不满足条件 输出子集个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> si in S:</span><br><span class="line">    S-si == u</span><br><span class="line">    <span class="keyword">delete</span> si</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ki in S-si:</span><br><span class="line">    <span class="keyword">if</span> S-si-ki == U:</span><br><span class="line">    <span class="keyword">delete</span>  ki</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><strong>特点</strong>：不一定是全局最优的，但是可以满足大部分情况</p>
</blockquote>
<h5 id="2-3-数学转化-math-formulation"><a href="#2-3-数学转化-math-formulation" class="headerlink" title="2.3 数学转化 math formulation"></a>2.3 数学转化 math formulation</h5><blockquote>
<p><strong>思路</strong>：将问题转成一个integer liner problem，然后再松弛成liner problem 进行求解。</p>
<p><img src="https://img-blog.csdnimg.cn/20200906145403132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5OTAyMg==,size_16,color_FFFFFF,t_70" alt="1"></p>
<p><img src="https://img-blog.csdnimg.cn/20200906160725739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5OTAyMg==,size_16,color_FFFFFF,t_70" alt="2"></p>
</blockquote>
<h4 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h4><ul>
<li><a href="https://www.geeksforgeeks.org/set-cover-problem-set-1-greedy-approximate-algorithm/">GeeksforGeeks</a></li>
<li>Set Cover Problem | Set 1 (Greedy Approximate Algorithm)</li>
<li>Vertex Cover Problem | Set 1 (Introduction and Approximate Algorithm)</li>
<li>Vertex Cover Problem | Set 2 (Dynamic Programming Solution for Tree)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20211221-Pareto最优</title>
    <url>/2021/12/21/20211221-Pareto%E6%9C%80%E4%BC%98/</url>
    <content><![CDATA[<h3 id="Pareto-Optimality-帕累托最优"><a href="#Pareto-Optimality-帕累托最优" class="headerlink" title="Pareto Optimality 帕累托最优"></a>Pareto Optimality 帕累托最优</h3><p>帕累托最优，是经济学中的重要概念，并且在博弈论、工程学和社会科学中有着广泛的应用。</p>
<span id="more"></span>
<h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li><p>帕累托改善：要求在提高某些人福利的时候不能减少任何一个人的福利。</p>
<blockquote>
<p>和<strong>功利主义</strong>的比较：功利主义允许提高福利总和而减少一些人的福利。</p>
</blockquote>
</li>
<li><p>帕累托最优：不可能再有更多的<strong>帕累托改善</strong>的情况，即不可能在不使任何其他人受损的情况下再改善某些人的情况。<font color='orange'><strong>从此以后，非损人不能利己。</strong></font></p>
</li>
</ul>
<h4 id="2-举例"><a href="#2-举例" class="headerlink" title="2. 举例"></a>2. 举例</h4><ul>
<li><p>示例1：</p>
<blockquote>
<p>假设现在有两个人，甲和乙，分10块蛋糕，并且两个人都喜欢吃蛋糕。10块蛋糕无论在两个人之间如何分配，都是帕累托最优，因为你想让某一个人拥有更大利益的唯一办法是从另一个人手里拿走蛋糕，导致的结果是那个被拿走蛋糕的人利益受损。</p>
</blockquote>
</li>
<li><p>示例2：</p>
<blockquote>
<p>假设现在有两个人，甲和乙，分10块蛋糕10个包子。甲喜欢吃蛋糕而乙喜欢吃包子，而且甲讨厌吃包子，乙讨厌吃蛋糕（甲包子吃得越多越不开心，乙蛋糕吃得越多越不开心）。这种情形下，帕累托最优应当是：把10块蛋糕全部给甲，把10个包子全部给乙。因为任何其他的分配都会使得至少一个人手里拿着一些自己讨厌的东西，比如甲拥有10块蛋糕以及2个包子，乙拥有8个包子。这个时候，如果把2个包子从甲的手里转移到乙的手里，甲和乙都变得比原来更开心了，同时这样的转移并不会使得任何一方的利益受损。</p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20211225-Primal-Dual原对偶问题</title>
    <url>/2021/12/25/20211225-Primal-Dual%E5%8E%9F%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="Primal-Dual原始-对偶问题"><a href="#Primal-Dual原始-对偶问题" class="headerlink" title="Primal-Dual原始-对偶问题"></a>Primal-Dual原始-对偶问题</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><ul>
<li>Prime-Dual的意义：可以给很多组合优化问题，尤其是网络设计问题提供近似算法。</li>
<li>应用：哈密顿回路、最大匹配的经典解法Blossom Algorithm；</li>
</ul>
<span id="more"></span>
<h4 id="2-拉格朗日函数"><a href="#2-拉格朗日函数" class="headerlink" title="2. 拉格朗日函数"></a>2. 拉格朗日函数</h4><ul>
<li>解决带约束条件的优化问题的一般解法：拉格朗日乘子法，步骤为：<ul>
<li>先写出拉格朗日函数；</li>
<li>对$x$求导得到导数为0的点；</li>
<li>将该点代回原函数，其中最大值即为原函数的最大值，最小值即为原函数的最小值。</li>
</ul>
</li>
<li>上述凸优化问题的拉式函数为：</li>
</ul>
<script type="math/tex; mode=display">
\begin{equation}
L(x, u, v)=f_{0}(x)+\sum_{i=1}^{m} u_{i} f_{i}(x)+\sum_{j=1}^{p} v_{j} h_{j}(x)
\end{equation}</script><ul>
<li>对于固定的$x$而言，$L(x,u,v)$为$u$和$v$的仿射函数。</li>
<li>至此，我们就把原来的求解带约束条件的原函数转换为了不带约束条件的拉格朗日函数</li>
</ul>
<h4 id="3-拉格朗日对偶函数"><a href="#3-拉格朗日对偶函数" class="headerlink" title="3. 拉格朗日对偶函数"></a>3. 拉格朗日对偶函数</h4><ul>
<li>求解$\min _{x} f_{0}(x)$，等价于求解：$\min _{x} \max _{u, v} L(x, u, v)$；</li>
<li>但是上式并不容易求解，由此引入了拉格朗日对偶函数<font color='cornflowerblue'><strong>（不是对偶问题）</strong></font>，即：</li>
</ul>
<script type="math/tex; mode=display">
\begin{equation}
g(u, v)=\inf _{x \in D} L(x, u, v)=\inf _{x \in D}\left[f_{0}(x)+\sum_{i=1}^{m} u_{i} f_{i}(x)+\sum_{j=1}^{p} v_{j} h_{j}(x)\right]
\end{equation}</script><ul>
<li>其中，$\underset{x\in D}{\mathop{\inf }}\,$表示函数逐点对$x$求下确界，即对任意$u$和$v$求出一个使得$L(x,u,v)$最小的$x$；</li>
<li>当拉式函数没有下确界的时候，定义下确界为$-\infty$，$D$是可行域。</li>
<li>拉格朗日对偶函数是一个凹函数，即它存在一个唯一的极大值点。</li>
</ul>
<h4 id="4-Set-Cover问题举例"><a href="#4-Set-Cover问题举例" class="headerlink" title="4. Set Cover问题举例"></a>4. Set Cover问题举例</h4><ul>
<li>给出一个集合的实例$I$，其对应的最小优化问题也即原始问题（primal）会存在一系列的可行解，定义每个实例$I$对应的最小可行解对应的花费（cost）为$OPT(I)$ ；</li>
<li>同理，在最大化优化问题也即对偶问题（dual）中其对应的最大可行解对应的利润（profit）为$OPT(I)$。</li>
</ul>
<h4 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h4><ul>
<li><a href="https://blog.csdn.net/zuzhiang/article/details/103293545">https://blog.csdn.net/zuzhiang/article/details/103293545</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20211225-如何理解0-1背包是NPC问题</title>
    <url>/2021/12/25/20211225-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A30-1%E8%83%8C%E5%8C%85%E6%98%AFNPC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="如何理解0-1背包是NPC问题"><a href="#如何理解0-1背包是NPC问题" class="headerlink" title="如何理解0-1背包是NPC问题?"></a>如何理解0-1背包是NPC问题?</h3><h4 id="1-分析"><a href="#1-分析" class="headerlink" title="1. 分析"></a>1. 分析</h4><blockquote>
<ul>
<li><p>在0-1背包问题中，我们需要2个输入（一个数组和一个整数）来解决这个问题。</p>
<ul>
<li>n个项目的数组$\{n_1, n_2, …\}$，每个项目都有它的价值指数和权重指数；</li>
<li>整数W作为最大可接受的重量。</li>
</ul>
</li>
<li><p>假设<code>n=10, W=8</code>，则：</p>
<p><code>n = [n1, n2, ..., n10], W=1000</code>，因此时间复杂度为<code>T（n）= O（nW）= O（80）</code>。</p>
</li>
<li><p>若将<code>n</code>的大小加倍：<code>T（n）= O（nW）= O（20 * 8）= O（160）</code>;</p>
</li>
<li>若将<code>W</code>的大小加倍：并不意味着W = 20，而是长度是两倍，即<code>W = 10000000</code>，因此：<code>T（n）= O（nW）= 0（10 * 128）= 0（1280）</code>；</li>
<li>因此所需时间以<font color='cornflowerblue'><strong>指数</strong></font>增加，这是一个<font color='orange'><strong>NPC问题</strong></font>。</li>
<li>因此，它是一个伪多项式。</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>20211225-组合数学概述</title>
    <url>/2021/12/25/20211225-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="组合数学概述"><a href="#组合数学概述" class="headerlink" title="组合数学概述"></a>组合数学概述</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><blockquote>
<p>组合数学，也叫离散优化，是运筹优化的重要组成部分。</p>
<p>组合优化是要从呈组合数复杂度爆炸式增长的解空间中，寻找最优的解向量，即指定最优决策方案。</p>
<p>组合优化问题涉及了分配、调度、指挥、路由等众多类型的问题，并且她与统计学习存在密切关系。</p>
<ul>
<li><p><strong>统计学习</strong>更侧重于预测和单步决策，比如：</p>
<ul>
<li>预测出了某件商品的销量，就可以知道需要进多少货；</li>
<li>预测出了某个区域的人流量，就可以知道需要分配多少保安巡逻；</li>
<li>检测出患者患有某种疾病，就可以知道开什么药。</li>
</ul>
</li>
<li><p><strong>组合优化</strong>更侧重多方的、全局的、系统性的序列决策。同时，离散优化与连续优化在思想上有很多相通之处。</p>
</li>
</ul>
</blockquote>
<span id="more"></span>
<h4 id="2-组合优化包含的问题"><a href="#2-组合优化包含的问题" class="headerlink" title="2. 组合优化包含的问题"></a>2. 组合优化包含的问题</h4><blockquote>
<ul>
<li><strong>路由问题</strong>：用开销最小的路径覆盖所有目的地。<ul>
<li>车辆路由</li>
<li>数据流量路由</li>
</ul>
</li>
<li><strong>指派问题</strong>：在有限的时间和空间中合理使用软硬件资源创造更多的收益。<ul>
<li>时间指派：<ul>
<li>先后序调度：单机作业调度、车间流水线调度</li>
<li>时间槽分配：航班与列车时刻表、人员排班表、选修课表</li>
</ul>
</li>
<li>空间指派：<ul>
<li>哪个背包装哪些物品：背包问题；</li>
<li>哪个处理器处理作业：多级作业调度；</li>
<li>哪个中心服务哪些客户：中心选址；</li>
</ul>
</li>
</ul>
</li>
<li><strong>NPC</strong>：可以在多项式时间内相互规约。</li>
</ul>
</blockquote>
<h4 id="3-如何定义一个问题"><a href="#3-如何定义一个问题" class="headerlink" title="3. 如何定义一个问题"></a>3. 如何定义一个问题</h4><blockquote>
<ul>
<li>基本要素：<ul>
<li>已知：输入数据；</li>
<li>决策：输出结果；</li>
<li>决策：输出结果可行还是不可行；</li>
<li>目标：输出结果好还是坏；</li>
</ul>
</li>
<li>观察问题的不同角度举例：<ul>
<li>图着色问题<ul>
<li>每个节点染什么颜色；</li>
<li>每种颜色的节点集合包含了哪些节点。</li>
</ul>
</li>
<li>布尔表达式可满足性问题<ul>
<li>保证每个布尔变量在所有子句中取值一致，最大化为真的子句数量；</li>
<li>保证每个子句为真，最大化布尔变量的一致性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4-基本求解方法分类"><a href="#4-基本求解方法分类" class="headerlink" title="4. 基本求解方法分类"></a>4. 基本求解方法分类</h4><blockquote>
<ul>
<li>贪心算法：在保证求解速度的前提下提升精度【部分可以保证最优性的贪心算法往往可以归类为DP（e.g. Dijkstra算法）】；</li>
<li>近似算法：离最优解的差距有保障的贪心算法；</li>
<li>精确算法：在确保最优性的前提下降低复杂度；<ul>
<li>深度/广度/优先度优先树搜索</li>
<li>动态规划</li>
<li>混合整数规划的求解算法</li>
</ul>
</li>
<li>启发式算法：在优度和复杂度之间寻找平衡点<ul>
<li>基于<strong>邻域动作</strong>：元启发式算法<ul>
<li>单个解：局部搜索；</li>
<li>多个解：种群算法；</li>
</ul>
</li>
<li>基于<strong>树搜索</strong>：<ul>
<li>A*：启发函数可接受时为精确算法；</li>
<li>向前看树搜索（Lookahead Tree Search）</li>
<li>线搜索（Beam Search）</li>
<li>蒙特卡洛树搜索（Monte-Carlo Tree Search）</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="5-问题规约与转换"><a href="#5-问题规约与转换" class="headerlink" title="5. 问题规约与转换"></a>5. 问题规约与转换</h4><blockquote>
<ul>
<li><strong>经典问题到现实问题</strong>：<ul>
<li>图着色<ul>
<li>寄存器分配</li>
<li>多业务波长分配</li>
<li>停机位分配</li>
<li>宿舍分配</li>
</ul>
</li>
<li>旅行销售员<ul>
<li>快递与外卖配送</li>
<li>物资采购</li>
<li>人类基因组计划</li>
</ul>
</li>
</ul>
</li>
<li><strong>经典问题相互转换</strong>：<ul>
<li>独立集 == 最大团 == 顶点覆盖 == 支配集 == 集合覆盖 == 中心选址</li>
<li>非对称旅行商 == 对称旅行商</li>
<li>必经点最短简单路 == 非对称旅行商 == 最短简单路 == 最长简单路</li>
</ul>
</li>
<li><strong>经典问题分解</strong>：<code>图着色 = 集合覆盖 + 独立集</code></li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>20220101-《算法导论》第25章-每对顶点间的最短距离</title>
    <url>/2022/01/01/20220101-%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%AC25%E7%AB%A0-%E6%AF%8F%E5%AF%B9%E9%A1%B6%E7%82%B9%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h3 id="学习笔记：《算法导论》第25章-每对顶点间的最短距离"><a href="#学习笔记：《算法导论》第25章-每对顶点间的最短距离" class="headerlink" title="学习笔记：《算法导论》第25章-每对顶点间的最短距离"></a>学习笔记：《算法导论》第25章-每对顶点间的最短距离</h3><h4 id="0-提出背景"><a href="#0-提出背景" class="headerlink" title="0. 提出背景"></a>0. 提出背景</h4><ul>
<li>问题：对一张公路图，需要制表说明每对城市间的距离。</li>
<li>概述：<ul>
<li>基于矩阵乘法的动态规划算法，求解每对顶点间的最短路径问题【重复平方】；</li>
<li>动态规划算法Floyd-Warshall算法；</li>
<li>有向图传递闭包问题【与每对顶点间最短路径有关系】；</li>
<li>Johnson算法【采用图的邻接表表示法】；</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h4 id="1-最短路径与矩阵乘法"><a href="#1-最短路径与矩阵乘法" class="headerlink" title="1. 最短路径与矩阵乘法"></a>1. 最短路径与矩阵乘法</h4><ul>
<li><p>基于<font color='cornflowerblue'><strong>动态规划</strong></font>算法，用来解决有向图上每对顶点间的最短路问题；</p>
</li>
<li><p>动态规划的每一次主循环都将引发一个与矩阵乘法十分相似的操作，因此算法看上去很像是重复的矩阵乘法；</p>
</li>
<li><p><strong>设计思想</strong>：通过把最短路径延长，最终计算出最短路径权值；</p>
</li>
<li><p><strong>设计步骤</strong>：</p>
<ul>
<li><p>最短路径的结构</p>
<blockquote>
<p>$\delta(i, j)=\delta(i, k)+w_{k j}$；</p>
</blockquote>
</li>
<li><p>每对顶点间最短路径问题的一个递归解：</p>
<blockquote>
<ul>
<li>$n$：顶点数量；</li>
<li><p>$l_{i j}^{(m)}$：表示从顶点i到顶点j的至多包含m条边的任何路径的权值最小值；</p>
</li>
<li><p>当m大于等于1时，有：</p>
<p>$l_{i j}^{(m)}=\min \left(l_{i j}^{(m-1)}, \min _{1 \leq k \leqslant n}\left\{l_{i k}^{(m-1)}+w_{k j}\right\}\right)=\min _{1 \leq k \leqslant n}\left\{l_{i k}^{(m-1)}+w_{k j}\right\}$；</p>
<p>其中第二个等式成立，是因为$w_{jj}=0$；</p>
</li>
<li><p>$\delta(i, j)$：表示实际最短路径权值；</p>
</li>
<li><p>当$\delta(i, j)&lt;\infty$：存在一条从i到j的最短路径，且为简单路径，从而最多包含n-1条边；</p>
<p>由于从顶点i到顶点j的对于n-1条边的路径权值不可能小于从i到j的最短路径的权值，因此实际的最短路径权值：$\delta(i, j)=l_{i j}^{(n-1)}=l_{i j}^{(n)}=l_{i j}^{(n+1)}=\cdots$；</p>
</li>
</ul>
</blockquote>
</li>
<li><p>自底向上计算最短路径的权值：</p>
<blockquote>
<ul>
<li>输入：$W=\left(w_{i j}\right)$</li>
<li>输出：$L^{(1)}, L^{(2)}, \cdots, L^{(n-1)}$，且$L^{(m)}=\left(l_{i j}^{(m)}\right)$；</li>
<li>用$L$表示$L^{(m-1)}$；</li>
<li>用$L^{\prime}$表示$L^{(m)}$；</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>和矩阵乘法的联系</strong>：</p>
<blockquote>
<ul>
<li><p>矩阵乘法：$c_{i j}=\sum_{k=1}^{n} a_{i k} \cdot b_{k j}$</p>
</li>
<li><p>替换：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}l^{(m-1)} & \rightarrow a \\ w & \rightarrow b \\ l^{(m)} & \rightarrow c \\ \min & \rightarrow+ \\ + & \rightarrow .\end{array}</script></li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="2-Floyd-Warshall算法"><a href="#2-Floyd-Warshall算法" class="headerlink" title="2. Floyd-Warshall算法"></a>2. Floyd-Warshall算法</h4><ul>
<li><p><strong>提出</strong>：允许存在权值为负的边，但是不存在权值为负的回路；</p>
</li>
<li><p><strong>中间节点</strong>：简单路径$p={v_1,v_2,…v_l}$上的中间顶点是除了$v_1$和$v_l$以外上的任何一个顶点，即任何属于集合${v_2,v_3,…,v_{l-1}}$的顶点；</p>
</li>
<li><p><strong>设计思路</strong>：利用了路径p与从i到j之间的最短路径之间的联系；</p>
</li>
<li><p><strong>设计步骤</strong>：</p>
<ul>
<li><p>最短路径的结构</p>
<blockquote>
<ul>
<li><p>如果k不是路径p的中间顶点：p的所有中间节点都在$\{1,2,…,k-1\}$中，因此从顶点i到顶点j且满足所有中间顶点皆属于$\{1,2,…,k-1\}$的一条最短路径，同样也是从i到j且满足所有中间顶点皆属于集合$\{1,2,…,k\}$的一条最短路径；</p>
</li>
<li><p>如果k是路径p的中间顶点：因为k不是路径p1上的一个中间顶点，所以p1是从i到k的一条最短路径，且其所有中间顶点均属于集合$\{1,2,…,k-1\}$；类似地，p2是从k到j的一条最短路径，且其所有中间顶点均属于集合$\{1,2,…,k-1\}$；</p>
<p> <img src="C:\Users\kunkun\AppData\Roaming\Typora\typora-user-images\image-20220101111423027.png" alt="image-20220101111423027" style="zoom:50%;" /></p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="3-稀疏图上的Johnson算法"><a href="#3-稀疏图上的Johnson算法" class="headerlink" title="3. 稀疏图上的Johnson算法"></a>3. 稀疏图上的Johnson算法</h4><ul>
<li><strong>提出</strong>：运用了<strong>重赋权</strong>技术；</li>
<li><strong>执行方式</strong>：如果所有边权w非负，则把每对顶点依次作为源点来执行Dijkstra算法，就可以找出每对顶点间的最短路径，可以使用斐波那契最小优先队列进行优化；如果G含有负权边但是不含有负权的回路，就只计算一个心的负权边的集合。</li>
<li>重赋权值不会改变最短路径。</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>20220101-《算法导论》第26章-最大流</title>
    <url>/2022/01/01/20220101-%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%AC26%E7%AB%A0-%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    <content><![CDATA[<h3 id="学习笔记：《算法导论》第26章-最大流"><a href="#学习笔记：《算法导论》第26章-最大流" class="headerlink" title="学习笔记：《算法导论》第26章-最大流"></a>学习笔记：《算法导论》第26章-最大流</h3><h4 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h4><ul>
<li>可以将有向图理解成一个”流网络“，用来回答有关物流方面的问题。</li>
<li>设想某物质从产生它的源点经过一个系统，流向消耗该物资的过程。源点以固定速度产生该物质，而汇点则用同样的速度消耗该物质。从直观上看，系统中任何一点的物质的”流“为该物质在系统中运行的速度；</li>
<li><strong>应用场景</strong>：模型化流经管道的液体、通过装配线的部件、电网中的电流或通讯网络传送的信息等；</li>
</ul>
<span id="more"></span>
<h4 id="1-最大流的概念"><a href="#1-最大流的概念" class="headerlink" title="1. 最大流的概念"></a>1. 最大流的概念</h4><ul>
<li>流网络中的每条有向边可以被认为是传输物质的管道。</li>
<li>每个管道都有一个固定的容量，可以看作是物质能够流经该管道的最大速度。</li>
<li><strong>流守恒（flow conservation）</strong>：物质进入某顶点的速度必须等于该顶点的速度。</li>
<li>当物质是电流时，流守恒与基尔霍夫电流定律等价；</li>
<li><strong>最大流问题：</strong>在不违背容量限制的条件下，把物质从源点传输到汇点的最大速率是多少；</li>
<li><strong>流网络</strong>：<ul>
<li>$G=(V, E)$是一个有向图，其中每条边$(u, v) \in E$均有一非负容量$c(u, v) \geqslant 0$。如果$(u, v) \notin E$，则假定$c(u, v)=0$。</li>
</ul>
</li>
<li><strong>流：</strong><ul>
<li>$G=(V, E)$是一个有向图，其容量函数为$c$。设$s$为网络的源点，$t$为汇点。$G$的流是一个实值函数$f: V \times V \rightarrow \mathbf{R}$，且满足下列<font color='orange'><strong>三个性质</strong></font>：<ul>
<li><font color='cornflowerblue'><strong>容量限制</strong></font>：对所有$u, v \in V$，要求$f(u, v) \leqslant c(u, v)$；</li>
<li><font color='cornflowerblue'><strong>容量守恒</strong></font>：对所有$u \in V-\{s, t\}$，要求$\sum_{v \in V} f(u, v)=0$；</li>
<li><font color='cornflowerblue'><strong>反对称性</strong></font>：对所有$u, v \in V$，要求$f(u, v)=-f(v, u)$；</li>
</ul>
</li>
<li>$f(u, v)$：称为从顶点u到顶点v的<strong>流</strong>；</li>
<li><strong>流$f$的值</strong>：$|f|=\sum_{v \in V} f(s, v)$，即从源点出发的总流；</li>
</ul>
</li>
<li>最大流问题实际上是给出一个具有源点$s$和汇点$t$的流网络$G$，希望找出从$s$到$t$的最大值流；</li>
<li><strong>对流的处理：</strong><ul>
<li>隐含求和记号：其中任何一个自变量或两个自变量可以是顶点的集合，他们所表示的值是对自变量所代表元素的所有可能情形求和。例如，如果X和Y是顶点的集合，则：$f(X, Y)=\sum_{x \in X} \sum_{y \in Y} f(x, y)$；</li>
</ul>
</li>
<li><strong>几个引理：</strong><ul>
<li>对所有$X \subseteq V, f(X, X)=0$；</li>
<li>对所有$X, Y \subseteq V, f(X, Y)=-f(Y, X)$；</li>
<li>对所有$X, Y, Z \subseteq V$，其中$X \cap Y=\varnothing$，有：<ul>
<li>$f(X \cup Y, Z)=f(X, Z)+f(Y, Z)$；</li>
<li>$f(Z, X \cup Y)=f(Z, X)+f(Z, Y)$；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-Ford-Fulkerson方法"><a href="#2-Ford-Fulkerson方法" class="headerlink" title="2. Ford-Fulkerson方法"></a>2. Ford-Fulkerson方法</h4><ul>
<li><p>Ford-Fulkerson方法依赖于三种重要思想：</p>
<ul>
<li>残留网络（residual network）；</li>
<li>增广路径（augmenting path）：可以看作是从源点s到汇点t之间的一条路径，沿该路径可以压入更多的流，从而增加流的值；</li>
<li>割（cut）【用流网络的割来描述最大流的值】；</li>
</ul>
</li>
<li><p>Ford-Fulkerson方法是一种迭代方法：</p>
<ul>
<li>初始状态时流的值为0；</li>
<li>在每次迭代中，可以通过寻找一条”增广路径“来增加流值；</li>
<li>重复上一步骤，知道所有增广路径均被找出位置；</li>
</ul>
</li>
<li><p>最大流最小割定理说明：当算法停止时，上述过程可以产生最大流；</p>
</li>
<li><p><strong>残留网络：</strong>假设$f$为$G$中的一个流，并考察一对顶点$u, v \in V$：</p>
<ul>
<li><strong>残留容量</strong>：在不超过容量$c(u,v)$的条件下，从u到v之间可以压入的额外网络流量，就是$(u,v)$的残留容量，定义为：$c_{f}(u, v)=c(u, v)-f(u, v)$；</li>
<li><strong>残留网络</strong>：给定一个流网络$G=(V,E)$和流$f$，由$f$压得的G的残留网络是$G_{f}=\left(V, E_{f}\right)$, $\begin{equation}<br>E_{f}=\left\{(u, v) \in V \times V: c_{f}(u, v)&gt;0\right\}<br>\end{equation}$；</li>
</ul>
</li>
<li><p><font color='cornflowerblue'><strong>引理1：</strong></font>设$G=(V, E)$是源点为s、汇点为t的一个流网络，且f为G中的一个流。设$G_{f}$是由导出的G的残留网络，且$f^{‘}$为$G_{f}$中的一个流，那么定义$f+f^{‘}$是G中的一个流，其值为$\left|f+f^{\prime}\right|=|f|+\left|f^{\prime}\right|$；</p>
</li>
<li><p><strong>增广路径：</strong>残留网络$G_{f}$中从s到t的一条简单路径；</p>
</li>
<li><p><strong>残留容量</strong>：能够沿一条增广路径p的每条边传输的网络流的最大量为p的残留容量，定义为：</p>
<script type="math/tex; mode=display">
c_{f}(p)=\min \left\{c_{f}(u, v):(u, v)\right. 在  p  上  \}</script></li>
<li><p><font color='cornflowerblue'><strong>引理2：</strong></font>设$G=(V, E)$是一个流网络，f是G的一个流，并设p是$G_f$中的一条增广路径，定义函数$f_p$为：</p>
<script type="math/tex; mode=display">
f_{p}(u, v)= \begin{cases}c_{f}(p) & \text { 如果 }(u, v) \text { 在 } p \text { 上 } \\ -c_{f}(p) & \text { 如果 }(v, u) \text { 在 } p \text { 上 } \\ 0 & \text { 否则 }\end{cases}</script><p>​            则定义$f_p$为$G_f$上的一个流。</p>
</li>
<li><p><font color='cornflowerblue'><strong>引理3：</strong></font>通过 $f^{\prime}=f+f_{p}$ 定义一个函数 $f^{\prime}: V \times V \rightarrow \mathbf{R}$ ，则 $f^{\prime}$ 是 $G$ 的一个流， 其值$\left|f^{\prime}\right|=|f|+\left|f_{p}\right|&gt;|f|$；</p>
</li>
<li><p><strong>网络的最小割：</strong>是网络中所有割中具有最小容量的割；</p>
</li>
<li><p><strong>流网络的割：</strong>Ford-Fulkerson方法沿增广路径反复增加流，直至找出最大流时为止。</p>
</li>
<li><p><font color='cornflowerblue'><strong>引理4：</strong></font>设f是源点为s，汇点为t的流网络G中的一个流。并且(S，T)是G的一个割。则通过割(S，T)的净流为$f(S,T)=|f|$。</p>
</li>
<li><p><font color='cornflowerblue'><strong>引理5：</strong></font>对一个流网络G中任意流f来说，其值的上界为G的任意割的容量；</p>
</li>
<li><p><font color='orange'><strong>最大流最小割定理</strong></font>：如果f是具有源点s和汇点t的流网络G=(V,E)中的一个流，则下列条件等价：</p>
<ul>
<li>f是G的一个最大流；</li>
<li>残留网络$G_f$中不包含增广路径；</li>
<li>对G的某个割(S,T)，有$|f|=c(S,T)$；</li>
</ul>
</li>
<li><p><strong>Ford-Fulkerson算法：</strong></p>
<ul>
<li>在每次迭代中，找出任意增广路径$p$，并把沿$p$每条边的流$f$加上其残留容量$c_f(p)$。</li>
</ul>
</li>
<li><p><strong>Edmonds-Karp算法（EK算法）：</strong>使用bfs实现对增广路径$p$的计算；</p>
</li>
</ul>
<h4 id="3-最大流的经典应用：最大二分匹配"><a href="#3-最大流的经典应用：最大二分匹配" class="headerlink" title="3. 最大流的经典应用：最大二分匹配"></a>3. 最大流的经典应用：最大二分匹配</h4><blockquote>
<p>可以和匈牙利算法进行比较。</p>
</blockquote>
<h4 id="4-最大流24题"><a href="#4-最大流24题" class="headerlink" title="4. 最大流24题"></a>4. 最大流24题</h4><ul>
<li>cracked：<a href="https://blog.csdn.net/wscffaa/article/details/109580593">https://blog.csdn.net/wscffaa/article/details/109580593</a></li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>20220101-网络流24题</title>
    <url>/2022/01/01/20220101-%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/</url>
    <content><![CDATA[<h3 id="网络流24题"><a href="#网络流24题" class="headerlink" title="网络流24题"></a>网络流24题</h3><h4 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h4><div class="table-container">
<table>
<thead>
<tr>
<th>问题编号</th>
<th>问题名称</th>
<th>问题模型</th>
<th>转化模型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>飞行员配对方案问题</td>
<td>二分图最大匹配</td>
<td>网络最大流</td>
</tr>
<tr>
<td>2</td>
<td>太空飞行计划问题</td>
<td>最大权闭合图</td>
<td>网络最小割</td>
</tr>
<tr>
<td>3</td>
<td>最小路径覆盖问题</td>
<td>有向无环图最小路径覆盖</td>
<td>网络最大流</td>
</tr>
<tr>
<td>4</td>
<td>魔术球问题</td>
<td>有向无环图最小路径覆盖</td>
<td>网络最大流</td>
</tr>
<tr>
<td>5</td>
<td>圆桌问题</td>
<td>二分图多重匹配</td>
<td>网络最大流</td>
</tr>
<tr>
<td>6</td>
<td>最长递增子序列问题</td>
<td>最多不相交路径</td>
<td>网络最大流</td>
</tr>
<tr>
<td>7</td>
<td>试题库问题</td>
<td>二分图多重匹配</td>
<td>网络最大流</td>
</tr>
<tr>
<td>8</td>
<td>机器人路径规划问题</td>
<td></td>
<td>最小费用最大流</td>
</tr>
<tr>
<td>9</td>
<td>方格取数问题</td>
<td>二分图点权最大独立集</td>
<td>网络最小割</td>
</tr>
<tr>
<td>10</td>
<td>餐巾计划问题</td>
<td>线性规划网络优化</td>
<td>最小费用最大流</td>
</tr>
<tr>
<td>11</td>
<td>航空路线问题</td>
<td>最长不相交路径</td>
<td>最小费用最大流</td>
</tr>
<tr>
<td>12</td>
<td>软件补丁问题</td>
<td>最小转移代价</td>
<td>最短路径</td>
</tr>
<tr>
<td>13</td>
<td>星际转移问题</td>
<td>网路判定</td>
<td>网络最大流</td>
</tr>
<tr>
<td>14</td>
<td>孤岛营救问题</td>
<td>分层图最短路径</td>
<td>最短路径</td>
</tr>
<tr>
<td>15</td>
<td>汽车加油形式问题</td>
<td>分层图最短路径</td>
<td>最短路径</td>
</tr>
<tr>
<td>16</td>
<td>数字梯形问题</td>
<td>最大权不相交路径</td>
<td>最小费用最大流</td>
</tr>
<tr>
<td>17</td>
<td>运输问题</td>
<td>网络费用流量</td>
<td>最小费用最大流</td>
</tr>
<tr>
<td>18</td>
<td>分配问题</td>
<td>二分图最佳匹配</td>
<td>最小费用最大流</td>
</tr>
<tr>
<td>19</td>
<td>负载平衡问题</td>
<td>最小代价供求</td>
<td>最小费用最大流</td>
</tr>
<tr>
<td>20</td>
<td>深海机器人问题</td>
<td>线性规划网络优化</td>
<td>最小费用最大流</td>
</tr>
<tr>
<td>21</td>
<td>最长k可重区间集问题</td>
<td>最大权不相交路径</td>
<td>最小费用最大流</td>
</tr>
<tr>
<td>22</td>
<td>最长k可重线段集问题</td>
<td>最大权不相交路径</td>
<td>最小费用最大流</td>
</tr>
<tr>
<td>23</td>
<td>火星探险问题</td>
<td>线性规划网络优化</td>
<td>最小费用最大流</td>
</tr>
<tr>
<td>24</td>
<td>骑士共存问题</td>
<td>二分图最大独立集</td>
<td>网络最小割</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<font color='cornflowerblue'> 2022不摆烂: )  </font>

</blockquote>
]]></content>
  </entry>
  <entry>
    <title>20220104-EK求最大流</title>
    <url>/2022/01/04/20220104-EK%E6%B1%82%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    <content><![CDATA[<h3 id="EK求最大流"><a href="#EK求最大流" class="headerlink" title="EK求最大流"></a>EK求最大流</h3><h4 id="1-最大流知识点梳理"><a href="#1-最大流知识点梳理" class="headerlink" title="1. 最大流知识点梳理"></a>1. 最大流知识点梳理</h4><ul>
<li>基本概念<ul>
<li>流网络，不考虑反向边</li>
<li>可行流，不考虑反向边<ul>
<li>两个条件：容量限制、流量守恒</li>
<li><code>可行流的流量=从源点流出的流量-流入源点的流量</code></li>
<li>最大流是指<strong><font color='cornflowerblue'>最大可行流</font></strong></li>
</ul>
</li>
<li>残留网络，考虑反向边，残留网络的可行流$f^{‘}$ + 原图的可行流$f$ = 原图的另一个可行流<ul>
<li><code>|f&#39; + f| = |f&#39;| + |f|</code></li>
<li><code>|f&#39;|</code> 可能是负数</li>
</ul>
</li>
<li>增广路径</li>
<li>割<ul>
<li>割的定义</li>
<li>割的容量，不考虑反向边，最小割是指<strong><font color='cornflowerblue'>容量最小</font></strong>的割</li>
<li>割的流量，考虑反向边，<code>f(S, T) &lt;= c(S, T)</code></li>
<li>对于任意可行流$f$，任意割<code>[S, T]</code>，有<code>|f| = f(S, T) &lt;= c(S, T)</code></li>
<li>最大流最小割定理<ul>
<li>可行流$f$是最大流；</li>
<li>可行流$f$的残留网络中不存在增广路；</li>
<li>存在某个割<code>[S, T]</code>，有<code>|f| = c(S, T)</code>；</li>
</ul>
</li>
</ul>
</li>
<li>算法【网络流的时间复杂度just a joke】<ul>
<li><strong><font color='orange'>EK算法</font></strong> $O(nm^2)$</li>
<li><strong><font color='orange'>Dinic算法</font></strong> $O(n^2m)$</li>
</ul>
</li>
<li>应用<ul>
<li>二分图：二分图匹配、二分图多重匹配</li>
<li>上下界网络流：无源汇上下界可行流、有源汇上下界最大流、有源汇上下界最小流</li>
<li>多元汇最大流</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-EK算法具体实现"><a href="#2-EK算法具体实现" class="headerlink" title="2. EK算法具体实现"></a>2. EK算法具体实现</h4><blockquote>
<p><strong>思路：</strong>首先存下图，建立反向边，构建残余网络，在残余网络中不断寻找增广路径，维护残余网络，将其累加至答案中，知道找不到增广路径。具体代码如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], f[M], ne[M], idx;   <span class="comment">// f[i]代表编号为i的边的capacity</span></span><br><span class="line"><span class="keyword">int</span> q[N], d[N], pre[N]; <span class="comment">// 当前边的编号、走到这条边的路径中最小的权值（最大的可行流量）、当前边的前驱路径</span></span><br><span class="line"><span class="keyword">bool</span> st[N];             <span class="comment">// 标记bfs过程中已经达到了的点，防止重复搜索</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;   <span class="comment">// 构建正向边</span></span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx++;   <span class="comment">// 构建反向边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    </span><br><span class="line">    q[<span class="number">0</span>] = S, st[S] = <span class="literal">true</span>, d[S] = INF; <span class="comment">// 添加编号为1的边，终点为S</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!st[ver] &amp;&amp; f[i])&#123;   <span class="comment">// 如果当前边的终点还没有到达过，且当前这条边的权值大于0</span></span><br><span class="line">                st[ver] = <span class="literal">true</span>;</span><br><span class="line">                d[ver] = <span class="built_in">min</span>(d[t], f[i]);</span><br><span class="line">                pre[ver] = i;</span><br><span class="line">                <span class="keyword">if</span>(ver == T)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt] = ver;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;   <span class="comment">// 若当前残留网络中还可以找到增广路径，则累加到r中，并修改这条路径中正向边和反向边的权值</span></span><br><span class="line">        r += d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])&#123;  <span class="comment">// 回溯</span></span><br><span class="line">            f[pre[i]] -= d[T];</span><br><span class="line">            f[pre[i] ^ <span class="number">1</span>] += d[T];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;S&gt;&gt;T;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="built_in">EK</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-Dinic算法具体实现"><a href="#3-Dinic算法具体实现" class="headerlink" title="3. Dinic算法具体实现"></a>3. Dinic算法具体实现</h4><blockquote>
<p><strong>概念：</strong>在稀疏图上和EK算法效果差不多，但是在稠密图上优势明显。</p>
<p><strong>思路：</strong>EK算法在寻找增广路径时候是一条一条找的，显然比较低效。因此Dinic实现了多路增广；</p>
<ul>
<li><strong>多路增广：</strong>在使用EK算法时，由于我们使用bfs找增广路，当每次贪心取得一条增广路并增广后，我们从汇点沿着增广路往前走，很可能会遇见一些点实际经过的流量小于该点所有入度的容量和，或者说在残量网络中，该点的入度和出度均大于0。我们可以利用该店后向弧的残量向该点前向弧增广。由于涉及回溯，bfs不适用；</li>
<li><strong>当前弧优化：</strong>对于增广操作，对于任意节点，我们每增广它的一条前向弧，意味着这条弧后所有的边都被我们多路增广过了，当我们再次处理该节点时，可以不用考虑这条弧。或者说，如果一条边已经被增广过，那么它就没有可能被增广第二次。那么我们下一次进行增广时，可以不走那些已经被增广过的边。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, M = <span class="number">200010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], f[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> q[N], d[N], cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> ver = e[i]; <span class="comment">// 当前弧优化</span></span><br><span class="line">            <span class="keyword">if</span>(d[ver] == <span class="number">-1</span> &amp;&amp; f[i])&#123;</span><br><span class="line">                d[ver] = d[t] + <span class="number">1</span>;</span><br><span class="line">                cur[ver] = h[ver];</span><br><span class="line">                <span class="keyword">if</span>(ver == T)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt] = ver;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == T)  <span class="keyword">return</span> limit;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i])&#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="keyword">int</span> ver = e[i];</span><br><span class="line">        <span class="keyword">if</span>(d[ver] == d[u] + <span class="number">1</span> &amp;&amp; f[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">find</span>(ver, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line">            <span class="keyword">if</span>(!t)  d[ver] = <span class="number">-1</span>;</span><br><span class="line">            f[i] -= t;f[i ^ <span class="number">1</span>] += t, flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())    <span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF))  r += flow;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;S&gt;&gt;T;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="built_in">dinic</span>()&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>20220104-费用流</title>
    <url>/2022/01/04/20220104-%E8%B4%B9%E7%94%A8%E6%B5%81/</url>
    <content><![CDATA[<h3 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h3><h4 id="1-最小费用最大流Minimum-Cost-Maximum-Flow"><a href="#1-最小费用最大流Minimum-Cost-Maximum-Flow" class="headerlink" title="1. 最小费用最大流Minimum Cost Maximum Flow"></a>1. 最小费用最大流Minimum Cost Maximum Flow</h4><ul>
<li>基本概念：网络上的每条边，除了容量外，还有一个属性：单位费用。一条边上的<code>费用 = 流量 × 单位费用</code>；</li>
<li>解决思路：我们已经知道，只要建了反向边，无论增广的顺序是怎样的，都能求出最大流。所以我们只需要每次都增广费用最少的一条路径即可。具体而言，<strong><font color='cornflowerblue'>将EK算法中的BFS换成SPFA</font></strong>即可；</li>
</ul>
<span id="more"></span>
<h4 id="2-典型举例"><a href="#2-典型举例" class="headerlink" title="2. 典型举例"></a>2. 典型举例</h4><ul>
<li><p><strong>模板题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>, M = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="keyword">sizeof</span> incf);</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh != tt)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span>(f[i] &amp;&amp; d[ver] &gt; d[t] + w[i])&#123;</span><br><span class="line">                d[ver] = d[t] + w[i];</span><br><span class="line">                pre[ver] = i;</span><br><span class="line">                incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line">                <span class="keyword">if</span>(!st[ver])&#123;</span><br><span class="line">                    q[tt++] = ver;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[ver] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">int</span>&amp; cost)</span></span>&#123;</span><br><span class="line">    flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = incf[T];</span><br><span class="line">        flow += t, cost += t * d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])&#123;</span><br><span class="line">            f[pre[i]] -= t;</span><br><span class="line">            f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;S&gt;&gt;T;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c, d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> flow, cost;</span><br><span class="line">    <span class="built_in">EK</span>(flow, cost);</span><br><span class="line">    cout&lt;&lt;flow&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cost&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>运输问题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">160</span>, M = <span class="number">5150</span> * <span class="number">2</span> + <span class="number">10</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="keyword">sizeof</span> incf);</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh != tt)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span>(f[i] &amp;&amp; d[ver] &gt; d[t] + w[i])&#123;</span><br><span class="line">                d[ver] = d[t] + w[i];</span><br><span class="line">                pre[ver] = i;</span><br><span class="line">                incf[ver] = <span class="built_in">min</span>(incf[t], f[i]);</span><br><span class="line">                <span class="keyword">if</span>(!st[ver])&#123;</span><br><span class="line">                    q[tt++] = ver;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[ver] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = incf[T];</span><br><span class="line">        cost += t * d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])&#123;</span><br><span class="line">            f[pre[i]] -= t;</span><br><span class="line">            f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    S = <span class="number">0</span>, T = m + n + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a;  cin&gt;&gt;a;</span><br><span class="line">        <span class="built_in">add</span>(S, i, a, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> b;  cin&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(m + i, T, b, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c;  cin&gt;&gt;c;</span><br><span class="line">            <span class="built_in">add</span>(i, m + j, INF, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="built_in">EK</span>()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx; i += <span class="number">2</span>)&#123;</span><br><span class="line">        f[i] += f[i ^ <span class="number">1</span>], f[i ^ <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        w[i] = -w[i], w[i ^ <span class="number">1</span>] = -w[i ^ <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;-<span class="built_in">EK</span>()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>负载平衡问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">610</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> n, S, T;</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="keyword">sizeof</span> incf);</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh != tt)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span>(f[i] &amp;&amp; d[ver] &gt; d[t] + w[i])&#123;</span><br><span class="line">                d[ver] = d[t] + w[i];</span><br><span class="line">                pre[ver] = i;</span><br><span class="line">                incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line">                <span class="keyword">if</span>(!st[ver])&#123;</span><br><span class="line">                    q[tt++] = ver;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[ver] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = incf[T];</span><br><span class="line">        cost += t * d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = T; i !=S; i = e[pre[i] ^ <span class="number">1</span>])&#123;</span><br><span class="line">            f[pre[i]] -= t;</span><br><span class="line">            f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    S = <span class="number">0</span>, T = n + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        tot += s[i];</span><br><span class="line">        <span class="built_in">add</span>(i, i &lt; n ? i + <span class="number">1</span> : <span class="number">1</span>, INF, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i, i &gt; <span class="number">1</span> ? i - <span class="number">1</span> : n, INF, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tot /= n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tot &lt; s[i])      <span class="built_in">add</span>(S, i, s[i] - tot, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot &gt; s[i]) <span class="built_in">add</span>(i, T, tot - s[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="built_in">EK</span>()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220106-朱刘算法</title>
    <url>/2022/01/06/20220106-%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="朱刘算法"><a href="#朱刘算法" class="headerlink" title="朱刘算法"></a>朱刘算法</h3><h4 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h4><ul>
<li>无向图：最小生成树；</li>
<li>有向图：最小树形图；</li>
</ul>
<span id="more"></span>
<ul>
<li><p><strong>联系：</strong>如果把一个树形图的有向边替换成无向边，它会变成一棵生成树。但不同于生成树，树形图中会确定一个根，它必须满足根能够到达每个结点。最小树形图是所有树形图中边权和最小的一个。</p>
<blockquote>
<p>首先我们知道 【树】的根节点没有入边 出边可以无限多，而其他节点出边也可以无限多 但<strong><font color='cornflowerblue'>入边只有一条</font></strong>。</p>
<p>既然要所有点都在树内 我们就贪心地选取<strong><font color='cornflowerblue'>所有入点u的边中权值最小的</font></strong>。</p>
<p>如果此时能形成一棵树 那无疑就是最优解,可以直接直觉认为 当前选的n-1条边中<strong><font color='cornflowerblue'>没有边成环就能形成树</font></strong>.</p>
<p>如果有环我们就进行<strong><font color='cornflowerblue'>缩点 </font></strong>【把在同一个环内的点看成一个点 同时更新指向环中任意一点的边权】</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/22858.png" alt="qaq"></p>
</blockquote>
</li>
</ul>
<!--more-->
<h4 id="1-算法"><a href="#1-算法" class="headerlink" title="1. 算法"></a>1. 算法</h4><ul>
<li><p><strong><font color='cornflowerblue'>基本思想：</font></strong>每次贪心地选出每个点最小的父亲，得出的图如果不是树形图，那么将选出的环进行缩点，对边权进行修改，然后迭代这个过程，直到图变为最小树形图为止。</p>
</li>
<li><p><strong><font color='cornflowerblue'>Tarjan优化（懒惰删除法🐕）：</font></strong> </p>
<ul>
<li>朱刘相当于最小生成树中B字开头的算法,而现在介绍的优化，其实相当于prim。</li>
<li>枚举每个<strong>原图</strong>中的节点x，然后不停地把边(pre[x],x)加入最小树形图，答案累加in[x]，在某一时刻发现出现了环，删除该环内部所有边，然后暴力把每个指向该环的边(u,v)，令边权减去in[v],然后将这个环缩成一个点,然后迭代进行，直至到达根节点r，这样还是O(nm)。</li>
<li>考虑优化，我们对于每个点x建一棵左偏树$T_x$，然后我们就可以在O(1)的时间复杂度查询一个节点的最小入边，缩环的时候直接合并左偏树即可，边权减打标记即可,因此我们需要很好的实现标记下放，一次对环的合并我们不妨及做log(n)，每个节点属于哪个环可以用<strong><font color='cornflowerblue'>并查集路径压缩+按秩合并</font></strong>，删除节点可以用延迟删除($N_5$)，那么最终时间复杂度不难分析的出来是O(m+nlog(n))。</li>
</ul>
<blockquote>
<ul>
<li>求没有确定的根的树形图:建立一个超级根r，以它为根跑算法,只要将r向原图每个点连接一条权值大于原图中所有边的边权的边，这样选这些边肯定不划算，因此只会选择一条。</li>
<li>判无解的奇技淫巧:从小到大依次枚举每个点i,加入边$(i,(i+1)\%n+1,+∞)$,这样如果你最后得到的答案为+∞，那么就无解了。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="2-应用"><a href="#2-应用" class="headerlink" title="2. 应用"></a>2. 应用</h4><ul>
<li><p>不确定根的最小树形图：</p>
<blockquote>
<p>这次我们不规定树形图的根，要求最小树形图。</p>
<p>容易发现我们建立一个超级源点，然后向每一个结点连长度为 infinf 的边，最后算出答案后减去 infinf 即可。发现为了使答案更优，最多只会从超级源点连出一条边，从而保证了去掉超级源点后的根是唯一的。</p>
<p>时间复杂度 O(nm)。</p>
</blockquote>
</li>
<li><p>滑雪</p>
<blockquote>
<p>朴素算法不能通过，考虑利用这题的性质。我们先搜出能够到达的所有点，再将边以终点高度为第一关键字，边权为第二关键字排序后，跑 Kruskal 即可。时间复杂度 O(mlogm)。</p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220106-Prufer编码</title>
    <url>/2022/01/06/20220106-Prufer%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h3 id="Prufer编码"><a href="#Prufer编码" class="headerlink" title="Prufer编码"></a>Prufer编码</h3><h4 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h4><ul>
<li>无根树和Prufer编码是一一对应的；</li>
</ul>
<span id="more"></span>
<h4 id="1-算法"><a href="#1-算法" class="headerlink" title="1. 算法"></a>1. 算法</h4><ul>
<li><p><strong><font color='cornflowerblue'>树编码为Prufer序列：</font></strong>Prufer序列初始为空。每次从树上选出一个编号最小的叶子节点，然后将与该叶子节点相邻的那个节点的编号写入prufer序列的末尾，之后从树上删掉这个叶子节点。循环这个步骤n-2次，最后得到一个长度为n-2的prufer序列（此时树中只有一条边，我们就不管它了）。具体步骤演示见<a href="https://www.cnblogs.com/jianglangcaijin/p/5989930.html">参考</a></p>
</li>
<li><p><strong><font color='cornflowerblue'>由Prufer序列得到树：</font></strong>首先，将每个节点的度数设为1加上该节点在Prufer序列中出现的次数。然后以下循环执行n-2次。第i次循环，选择此时度数为1的编号最小的节点u，将其与此时Prufer序列的第i个元素v连边，然后将u和v的度数都减去1。这n-2次执行完之后，仅剩下两个节点他们的度数都是1，将这两个点连边，这样就得到一个有n-1条边的树。具体步骤演示见<a href="https://www.cnblogs.com/jianglangcaijin/p/5989930.html">参考</a></p>
</li>
<li><p><strong><font color='cornflowerblue'>Cayley公式：</font></strong>n个节点带标号的无根树有$n^{n-2}$个。</p>
</li>
</ul>
<h4 id="2-应用"><a href="#2-应用" class="headerlink" title="2. 应用"></a>2. 应用</h4>]]></content>
  </entry>
  <entry>
    <title>20220107-二分图多重匹配</title>
    <url>/2022/01/07/20220107-%E4%BA%8C%E5%88%86%E5%9B%BE%E5%A4%9A%E9%87%8D%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h3 id="二分图多重匹配"><a href="#二分图多重匹配" class="headerlink" title="二分图多重匹配"></a>二分图多重匹配</h3><h4 id="1-二分图匹配、二分图多重匹配"><a href="#1-二分图匹配、二分图多重匹配" class="headerlink" title="1. 二分图匹配、二分图多重匹配"></a>1. 二分图匹配、二分图多重匹配</h4><ul>
<li><strong>简洁定义：</strong><ul>
<li><strong><font color='cornflowerblue'>二分图匹配：</font></strong>边数最多的匹配；</li>
<li><strong><font color='cornflowerblue'>二分图多重匹配：</font></strong>规定一个点要与L条边匹配。同时根据是否有边权，可划分为：<ul>
<li>二分图最大多重匹配；</li>
<li>二分图最大权多重匹配（二分图多重最佳完美匹配）；</li>
</ul>
</li>
</ul>
</li>
<li><strong>联系：</strong>当<code>L == 1</code>时，二分图多重匹配退化为二分图匹配。</li>
</ul>
<span id="more"></span>
<h4 id="2-二分图多重匹配算法"><a href="#2-二分图多重匹配算法" class="headerlink" title="2. 二分图多重匹配算法"></a>2. 二分图多重匹配算法</h4><ul>
<li><strong>二分图最大多重匹配：</strong><ul>
<li>在原图上建立源点S和汇点T；</li>
<li>S向每个X方点连一条容量为该X方点L值的边，每个Y方点向T连一条容量为该Y方点L值的边；</li>
<li>原来二分图中各边在新的网络中仍存在，容量为1（若该边可以使用多次则容量大于1）；</li>
<li>求网络的最大流，就是该二分图多重最大匹配的值。</li>
</ul>
</li>
<li><strong>二分图最大权多重匹配：</strong><ul>
<li>在原图上建立源点S和汇点T；</li>
<li>S向每个X方点连一条容量为该X方点L值、费用为0的边，每个Y方点向T连一条容量为该Y方点L值、费用为0的边；</li>
<li>原来二分图中各边在新的网络中仍存在，容量为1（若该边可以使用多次则容量大于1），费用为该边的权值；</li>
<li>求网络的最大费用流，就是该二分图多重最优匹配的值。</li>
</ul>
</li>
</ul>
<h4 id="3-典型例题"><a href="#3-典型例题" class="headerlink" title="3. 典型例题"></a>3. 典型例题</h4><ul>
<li><strong>稳定的牛分配</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220108-最近公共祖先</title>
    <url>/2022/01/08/20220108-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li><strong>定义</strong>：树上任意两点向根节点靠近的路上重合的深度最大的点；</li>
</ul>
<span id="more"></span>
<ul>
<li><p><strong>图示定义 </strong>：<strong><font color='cornflowerblue'>蓝色节点</font></strong>和<strong><font color='pink'>粉色节点</font></strong>的最近公共祖先是<strong><font color='green'>绿色点</font></strong>；</p>
<p><img src="https://s2.loli.net/2022/01/08/XPHlGNfWUedMEcQ.png" alt="image-20220108140328746.png"></p>
</li>
</ul>
<h4 id="2-求解LCA方法"><a href="#2-求解LCA方法" class="headerlink" title="2. 求解LCA方法"></a>2. 求解LCA方法</h4><ul>
<li><p><strong>向上标记法：</strong>暴力。两个节点平层同时向上跳，直到相遇，相遇的点即为LCA。如果有m次查询，那么时间复杂度为<code>O(mn)</code>。</p>
</li>
<li><p><strong>倍增法：</strong>如果使用暴力算法求解，对于深度较大的树需要很久的时间，考虑采用倍增的方式来优化，具体而言：</p>
<blockquote>
<ul>
<li><strong>符号表示</strong>：<ul>
<li><code>fa[i, j]</code>：表示从<code>i</code>开始，向上走$2^j$步，即表示节点<code>i</code>的第<code>j+1</code>位祖先。其中$0\le j\le \log n$；</li>
<li><code>depth[i]</code>：表示深度；</li>
<li><strong>哨兵</strong>：从<code>i</code>开始，向上走$2^j$步，如果跳过根节点，则<code>fa[i, j] = 0</code>,<code>depth[0] = 0</code>（表示节点0是第0层）。</li>
</ul>
</li>
<li><strong>步骤</strong>：<ul>
<li>先将两个点跳到同一层；</li>
<li>让两个点同时往上跳，一直跳到它们的最近公共祖先的下一层；</li>
</ul>
</li>
<li><strong>时间复杂度</strong>：预处理<font color='red'>$O(n\log n)$</font>、查询<font color='red'>$O(\log n)$</font>。</li>
<li>注：这里倍增的思想一部分来自<strong>整数拼凑（11 = 8 + 2 + 1 = 1011）</strong>。我们知道如果<code>fa[i,k]==fa[j,k]</code>，则说明在跳了$2^k$步之后找到了公共祖先，但是该节点不一定是最近的；但反之，如果<code>fa[i,k]!=fa[j,k]</code>，则说明节点<code>i</code>和节点<code>j</code>还没有找到公共祖先。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>Tarjan：</strong>优雅的<strong><font color='cornflowerblue'>离线求LCA</font></strong>做法，时间复杂度为<code>O(m + n)</code>。</p>
<blockquote>
<ul>
<li><p><strong>在线算法</strong>：读入一个输入，得到一个输出；</p>
</li>
<li><p><strong>离线算法</strong>：将输入全部读入，之后才处理输出；</p>
</li>
<li><p><strong>本质</strong>：对向上标记算法的优化。</p>
</li>
<li><p><strong>思想</strong>：首先深度优先遍历：</p>
<ul>
<li><p>如果当前节点涉及到某一个询问，且询问的另一个点已经访问过，则可以得出答案；</p>
</li>
<li><p>反之，标记节点<code>x</code>已访问过，直到访问到另一个节点。</p>
</li>
<li><p><strong>举例</strong>：假设询问为节点4和节点9，从根节点出发，访问到x并标记已访问；发现节点9并没有被访问，所以不管，继续走；回溯，遍历，当遇到9的时候，发现另一个点4已经访问过了，所以此时两个点的LCA就是更新到了的4的祖先，节点1。</p>
<p><img src="https://cdn.acwing.com/media/article/image/2019/05/18/1973_f79af40479-20190518163041445.png" alt="20190518163041445.png" style="zoom:50%;" /></p>
<p>如果在回溯的时候更新祖先节点，假设fa[x]为点x的祖先节点，从节点1→节点2→节点4→节点7，到达叶子节点之后回溯，标记<code>fa[7] = 4</code>；再遍历到节点8回溯，标记<code>fa[8] = 4</code>；继续回溯，标记<code>fa[4] = 2</code>；再遍历到节点5回溯，标记<code>fa[5] = 2</code>……随着回溯的当前层数越浅，各个节点最终指向的祖先也越来越高，所以如果另一个节点已经标记，说明那个点的祖先就一定时两个点的LCA。同时，在访问到一个点时，可以一并解决所有与这个点有关的询问，所以可以使用<strong>邻接表或向量</strong>来进行存储。</p>
</li>
<li><p>该思路基于深度优先遍历，可以将所有的点分为3类 ：</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/08/C4BN9hbyUmRlPce.png" alt="image-20220108174027363.png"></p>
<ul>
<li><strong><font color='cornflowerblue'>第1类</font></strong>：未被搜索过的点；</li>
<li><strong><font color='red'>第2类</font></strong>：正在搜索的分支；</li>
<li><strong><font color='green'>第3类</font></strong>：已经遍历过，且回溯过的点；</li>
</ul>
<p>其中第2类和第3类节点已经通过并查集合并成一个集合，因此具体步骤如下：</p>
<ul>
<li>在进入递归层时，将点标记为<code>1</code>；</li>
<li>搜索所有没有遍历过的边且与该点连接的点，搜索回溯后，完成集合合并；</li>
<li>将所有与该层点有关系的询问，全部遍历，当另一个点已经被标记为2，则找到了最近公共祖先，就是另一个点的并查集标记节点；</li>
<li>最后回溯时，将该节点标记为2；</li>
<li><p>注意：<font color='red'>先将要拓展的节点展开，回溯时再进行集合合并</font>。</p>
</li>
<li><p>首先求出所有点到根节点的距离<code>depth[]</code>，设节点<code>x</code>和节点<code>y</code>的最近公共祖先是<code>p</code>， 则节点<code>x</code>和节点<code>y</code>的最近距离为<code>depth[x] + depth[y] - 2* depth[p]</code>；</p>
</li>
<li>在深度优先遍历<code>1</code>号节点中的节点<code>u</code>时，需要把节点<code>u</code>的查询的另外一个点的最短距离进行计算并存储，最后把节点<code>u</code>合并到上一节点的集合。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>树剖：</strong>把一棵树按子树大小分为链。【<a href="https://blog.csdn.net/qq_43326267/article/details/89791152">参考</a>】</p>
<blockquote>
<ul>
<li><p><strong>基本操作：</strong>求x到y的路径边权和（或对所有边权进行修改）；</p>
</li>
<li><p><strong>启发：</strong>可以使用树剖思路解决LCA。具体而言，直接判断节点x和节点y是否在同一条链上：</p>
<ul>
<li>若不在同一条链上，则深度较大的节点跳转到链头的父节点，即跳出这条链；</li>
<li>若在同一条链上，则深度较浅的节点即为LCA。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p><strong><font color='orange'>定理：对于一张无向图，如果存在最小生成树和（严格）次小生成树，那么对于任何一颗最小生成树，都存在一棵（严格）次小生成树，使得这两棵树只有一条边不同。</font></strong></p>
</li>
</ul>
<h4 id="3-经典例题"><a href="#3-经典例题" class="headerlink" title="3. 经典例题"></a>3. 经典例题</h4><ul>
<li><p><strong>祖孙询问（倍增法）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40010</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> depth[N], fa[N][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.<span class="built_in">front</span>();  q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j] &gt; depth[t] + <span class="number">1</span>)&#123;    <span class="comment">// 说明j还没有被搜索过</span></span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;   <span class="comment">// 节点j的父节点为t</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">//从j跳2^k步长的距离，相当于从j连续跳两个2^(k-1)步长的距离</span></span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 保证a在b的下面</span></span><br><span class="line">    <span class="keyword">if</span>(depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="comment">// 移动a，使得a和b平层</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]] &gt;= depth[b])&#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a == b)  <span class="keyword">return</span> a;</span><br><span class="line">    <span class="comment">// 利用整数拼凑的思想，节点a和节点b同时上移直到找到公共节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[a][k] != fa[b][k])&#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环结束，到达LCA下一层</span></span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];    <span class="comment">// 返回节点a的父节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;   cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">-1</span>) root = a;</span><br><span class="line">        <span class="keyword">else</span>    <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bfs</span>(root);  <span class="comment">// 建树</span></span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;   cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span>(p == a)  <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p == b) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>距离（Tarjan算法）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N], p[N], res[M], st[N];</span><br><span class="line">vector&lt;PII&gt; query[N];   <span class="comment">// [查询另一个点, 查询序号]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dist[j] = dist[u] + w[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)   p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>;  <span class="comment">// 标记当前正在搜索的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;  <span class="comment">// 遍历所有邻点</span></span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            p[j] = u; <span class="comment">// 将节点j合并到父节点u中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item: query[u])&#123;</span><br><span class="line">        <span class="keyword">int</span> y = item.first, id = item.second;</span><br><span class="line">        <span class="keyword">if</span>(st[y] == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> anc = <span class="built_in">find</span>(y);</span><br><span class="line">            res[id] = dist[u] + dist[y] - dist[anc] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;   cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(a != b)&#123; <span class="comment">// 二者不相等的时候才需要记录查询</span></span><br><span class="line">            query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">            query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// 初始化dist数据，处理每个点和1号节点的距离</span></span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);  <span class="comment">// 随便拿一个点当作根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)  cout&lt;&lt;res[i]&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220108-路径重建</title>
    <url>/2022/01/08/20220108-%E8%B7%AF%E5%BE%84%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="路径重建"><a href="#路径重建" class="headerlink" title="路径重建"></a>路径重建</h3><p>本篇文章主要收集了和路径重建相关的算法题，希望会对目前所研究的问题带来些启发。</p>
<span id="more"></span>
<h4 id="1-阻断"><a href="#1-阻断" class="headerlink" title="1. 阻断"></a>1. 阻断</h4><blockquote>
<ul>
<li><p><strong>题意</strong>：<a href="https://www.luogu.com.cn/problem/P4374">https://www.luogu.com.cn/problem/P4374</a></p>
</li>
<li><p><strong>题解</strong>：<a href="https://www.luogu.com.cn/problem/solution/P4374">https://www.luogu.com.cn/problem/solution/P4374</a></p>
</li>
<li><p><strong>思路</strong>：【树剖+线段树】</p>
<p><img src="https://s2.loli.net/2022/01/09/hQMWTEGcfm5sqVC.png" alt="image.png"></p>
<ul>
<li>发现每次加入一条额外边，假设两端点分别为x和y，则这条边会和原来树上x和y之间的链构成一个环。这个环上的任何一条树边被砍断，断开的两个连通块一定可以通过我们刚加的这条额外边保持连通。同时，如果一条树边不在这个环上，那么如果砍断这条边，这条额外的边也无法使树保持连通。</li>
<li>因此我们进行边转点。在点的时间戳上建立线段树，线段树每片叶子维护“删掉这个点所代表的边后，使树连通需要的最短边的边权”。区间信息不用合并，因为是单点查询。</li>
<li>我们每次读入端点为x和y，权值为k的额外边，常规树剖写法，在树上以x和y为端点的链上进行min(k, w[i])；查询的时候先得到这条边对应的点，然后单点查询即可；</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> par[<span class="number">50010</span>][<span class="number">17</span>];</span><br><span class="line"><span class="keyword">int</span> dep[<span class="number">50010</span>], po[<span class="number">50010</span>], to[<span class="number">50010</span>];</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; G[<span class="number">50010</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; roads[<span class="number">50010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getto</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(to[x] == x)  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> to[x] = <span class="built_in">getto</span>(to[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = G[x][i].first, id = G[x][i].second;</span><br><span class="line">        <span class="keyword">if</span>(y == p)  <span class="keyword">continue</span>;</span><br><span class="line">        po[id] = y;</span><br><span class="line">        par[y][<span class="number">0</span>] = x;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">16</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[par[x][i]] &gt;= dep[y])&#123;</span><br><span class="line">            x = par[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y)  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">16</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(par[x][i] != par[y][i])&#123;</span><br><span class="line">            x = par[x][i], y = par[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> par[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;   cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        G[x].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(y, i));</span><br><span class="line">        G[y].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x, i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        roads[i] = <span class="built_in">make_pair</span>(z, <span class="built_in">make_pair</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dep[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            par[j][i] = par[par[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) to[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(roads+<span class="number">1</span>, roads+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = roads[i].first;</span><br><span class="line">        <span class="keyword">int</span> x = roads[i].second.first, y = roads[i].second.second;</span><br><span class="line">        <span class="keyword">int</span> xy = <span class="built_in">lca</span>(x, y);</span><br><span class="line">        <span class="keyword">for</span>(x = <span class="built_in">getto</span>(x); dep[x] &gt; dep[xy]; x = <span class="built_in">getto</span>(par[x][<span class="number">0</span>]))&#123;</span><br><span class="line">            ans[x] = v;</span><br><span class="line">            to[x] = par[x][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(y = <span class="built_in">getto</span>(y); dep[y] &gt; dep[xy]; y = <span class="built_in">getto</span>(par[y][<span class="number">0</span>]))&#123;</span><br><span class="line">            ans[y] = v;</span><br><span class="line">            to[y] = par[y][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)  cout&lt;&lt;ans[po[i]]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>20220108-树链剖分</title>
    <url>/2022/01/08/20220108-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li><p><strong>树链剖分</strong>（简称树剖）；</p>
</li>
<li><p><strong>重儿子</strong>：这里我理解为重（zhòng）儿子，因为它是某个节点众多子树中权值最大的子树的根节点。从该节点连向重儿子的边即为<strong><font color='red'>重边</font></strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20190503203931811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzI2MjY3,size_16,color_FFFFFF,t_70" alt="img"></p>
</li>
<li><p><strong>重链</strong>：由重边连接的点和边组成，即为<strong>树链</strong>；</p>
</li>
</ul>
<span id="more"></span>
<h4 id="2-树链的性质"><a href="#2-树链的性质" class="headerlink" title="2. 树链的性质"></a>2. 树链的性质</h4><ul>
<li>一条树链必是一个<strong><font color='cornflowerblue'>轻儿子</font></strong>或<strong><font color='cornflowerblue'>根节点</font></strong>开头，通过重边串起来一部分重儿子；</li>
<li>一个非叶子节点只有一个重儿子；</li>
<li>单独的叶子节点是一条树链，满足以轻儿子开头。因此<strong><font color='cornflowerblue'>一棵树必定可被划分为几条树链</font></strong>；</li>
</ul>
<h3 id="3-边转点"><a href="#3-边转点" class="headerlink" title="3. 边转点"></a>3. 边转点</h3><ul>
<li><p><strong><font color='cornflowerblue'>树剖+线段树：</font></strong>可以维护树上的点权区间；</p>
</li>
<li><p><strong><font color='cornflowerblue'>边转点：</font></strong>将边权转化为点权。可以维护边权区间；</p>
</li>
<li><p><strong>操作：</strong>由于每个点的父节点唯一，因此将边权给深度更大的那个点。</p>
<p><img src="https://s2.loli.net/2022/01/08/XHM8pwyZmizBftP.png" alt="image-20220108213833462.png"></p>
<p>从上面的图来看，第一个点没有值。因此需要注意：</p>
<ul>
<li>当完成边化点线段树维护操作后进行查询操作时，搜索范围应从2开始（或者赋值第一个点为极大值）；</li>
<li>由于每个点对应的边都是它到它父亲节点的边，所以在查询区间或修改区间时不能考虑LCA，区间应为[<code>dfn[son[lca]]</code>, <code>dfn[]</code>]。</li>
</ul>
</li>
</ul>
<h4 id="4-经典例题：树链剖分"><a href="#4-经典例题：树链剖分" class="headerlink" title="4. 经典例题：树链剖分"></a>4. 经典例题：<a href="https://www.luogu.com.cn/problem/P3384">树链剖分</a></h4><ul>
<li><p><strong>题意：</strong>共有4种操作：</p>
<blockquote>
<ul>
<li><code>1 x y z</code>：表示将树从<code>x</code>到<code>y</code>节点最短路径上所有节点的值都加上<code>z</code>；</li>
<li><code>2 x y</code>：表示求树从<code>x</code>到<code>y</code>节点最短路径上所有节点的值之和；</li>
<li><code>3 x z</code>：表示将以<code>x</code>为根节点的子树内所有节点值都加上<code>z</code>；</li>
<li><code>4 x</code>：表示求以<code>x</code>为根节点的子树内所有节点值之和。</li>
</ul>
</blockquote>
</li>
<li><p><strong>思路：</strong>采用LCA，可以先让两个点同时往上跳，直到某个值相同，之后可以一起操作。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220109-线段树</title>
    <url>/2022/01/09/20220109-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li><p><strong>定义</strong>：线段树是一棵满二叉树（除了最后一层），因此可以用堆（一维数组）进行存储；</p>
<p><img src="https://cdn.acwing.com/media/article/image/2021/08/12/92692_1e4b8ed7fb-image-20210812114439710.png" alt="image-20210812114439710.png" style="zoom:50%;" /></p>
<p>对于上图中的段，从上到下，从左到右依次编号1，2，3，……</p>
<p>对于某一段<code>u</code>：</p>
<ul>
<li>父节点为$\left\lfloor x/2 \right\rfloor $，即<code>u&gt;&gt;1</code>；</li>
<li>左儿子为（$2x$），即<code>u&lt;&lt;1</code>；</li>
<li>右儿子为（$2x+1$），即<code>u&lt;&lt;1 | 1</code>；</li>
</ul>
<p>同时在考虑存储空间时，倒数第二层最多有n个节点，倒数第一层最多有2n个节点，倒数第二层之前最多有(n-1)个节点，因此最多总共有(4n-1)个节点。因此我们需要开<font color='red'>$4n$</font>大小的空间。</p>
</li>
</ul>
<ul>
<li><strong>5种基本操作</strong>：<ul>
<li><code>push_up</code>：由子节点计算父节点，<strong><font color='cornflowerblue'>sum = L.sum + R.sum</font></strong>；</li>
<li><code>push_down</code>：将父节点修改信息下传至子节点，也被称作<strong><font color='red'>懒标记（或延迟标记）</font></strong>；</li>
<li><code>build</code>：将一段区间初始化为线段树；</li>
<li><code>modify</code>：修改<strong><font color='orange'>端点</font></strong>或修改<strong><font color='orange'>区间</font></strong>。</li>
<li><code>query</code>：查询某一段区间的信息。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>扫描线法</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220109-Polya.How to solve it</title>
    <url>/2022/01/09/20220109-Polya-How-to-solve-it/</url>
    <content><![CDATA[<h3 id="方法论-How-to-solve-it"><a href="#方法论-How-to-solve-it" class="headerlink" title="[方法论] - How to solve it"></a>[方法论] - How to solve it</h3><ul>
<li><strong><font color='cornflowerblue'>弄清问题</font></strong><ul>
<li>未知数是什么？已知数是什么？条件是什么？【输入 + 输出 + 约束】</li>
<li>满足条件是否可能？要确定未知数，条件是否充分？或者多余？还是矛盾？</li>
<li>画一张图，使用恰当的符号；</li>
<li>理清不同的条件，并尝试记录它们；</li>
</ul>
</li>
<li><strong><font color='cornflowerblue'>拟定计划</font></strong><ul>
<li>找出已知数和未知数之间的联系。如果没有直接的联系，就必须先考虑辅助性的问题。最终得到一个求解计划。<ul>
<li>你以前见过它吗？是否见过相同的或者形式稍有不同的问题？</li>
<li>是否知道与此相关的问题？或者一个可以用得上的定理？</li>
<li>看着未知数，想出一个有相同或者相似未知数的熟悉问题。</li>
<li>如果有一个与现在的问题有关并且早已解决的问题，你能否利用它？能否利用它的结果或方法？为了利用它是否应该先引入某些辅助元素？</li>
<li>能否重新叙述这个问题，尽可能地从不同的角度？很多时候必须回到定义中去。</li>
<li>如果你不能解决所提出的问题，可以尝试先解决一个与此有关的。你能否提出一个更容易着手的相关问题——像是一个更普遍的或者更特殊的，或者一个类比的问题？</li>
<li>能否解决这个问题的一部分？仅仅保留条件的一部分而舍弃其余，这样对于未知数能确定到什么程度？它还能怎样变化？你能否从已知数据推导出来某些有用的信息？你是否考虑过用其他数据来确定未知数？如果需要的话，你能否转化未知数或数据（或者二者同时），以使得新未知数和新数据联系更紧密？</li>
<li>你是否利用了所有的已知数据？你是否利用了全部的条件？你是否考虑了问题种包含的所有基本概念？</li>
</ul>
</li>
</ul>
</li>
<li><strong><font color='cornflowerblue'>实行计划</font></strong><ul>
<li>实现你的解题计划，检查每个步骤。你能否清楚地看出这一步骤的正确性？你能否证明？</li>
</ul>
</li>
<li><strong><font color='cornflowerblue'>回顾</font></strong><ul>
<li>验算所得到的解<ul>
<li>你能否验算这个解？能否解决争议？</li>
<li>你能否用别的方法得到这个解答？或者你其实能否一眼就看出它来？</li>
<li>你能否把本题的结果或方法应用于其他的问题？</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220116-Steiner树</title>
    <url>/2022/01/16/20220116-Steiner%E6%A0%91/</url>
    <content><![CDATA[<h3 id="Steiner树"><a href="#Steiner树" class="headerlink" title="Steiner树"></a>Steiner树</h3><p>斯坦纳树问题是组合优化问题，与最小生成树相似，是最短网络的一种。</p>
<ul>
<li>最小生成树是在给定的点集和边中寻求最短网络使所有点连通。</li>
<li>最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。</li>
</ul>
<span id="more"></span>
<h4 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1. 问题引入"></a>1. 问题引入</h4><ul>
<li>将三个村庄用总长为极小的道路连接起来。数学表述为：在平面内给定三个点 A、B、C找出平面内第四个点P，使得和数$a+b+c$为最短，这里$a、b、c$ 分别表示从P 到A、B、C的距离。</li>
<li>【问题推广】斯坦纳树问题：给定$n$个点 ，试求连接此$n$个点$A_1,A_2,…, A_n$，总长最短的直线段连接系统，并且任意两点都可由系统中的直线段组成的折线连接起来</li>
</ul>
<p><a href="https://oi-wiki.org/graph/steiner-tree/">https://oi-wiki.org/graph/steiner-tree/</a></p>
<h4 id="2-问题推广"><a href="#2-问题推广" class="headerlink" title="2. 问题推广"></a>2. 问题推广</h4><p><a href="https://oi-wiki.org/graph/steiner-tree/">https://oi-wiki.org/graph/steiner-tree/</a></p>
]]></content>
  </entry>
  <entry>
    <title>20220115-无标注网络</title>
    <url>/2022/01/15/20220115-%E6%97%A0%E6%A0%87%E6%B3%A8%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h3 id="无标注网络"><a href="#无标注网络" class="headerlink" title="无标注网络"></a>无标注网络</h3><ul>
<li><p><strong>ER随机网络</strong>：埃尔德什（Paul Erdos）-雷尼(Alfred Renyi)随机网络。生成网络描述如下：</p>
<blockquote>
<ol>
<li>从N个孤立节点开始；</li>
<li>选择一对节点，产生一个0-1之间的随机数。如果该随机数小于p，则这对节点之间放一条连接；否则，该节点对保持不连接；</li>
<li>对所有N(N-1)/2个节点对重复步骤2。</li>
</ol>
</blockquote>
</li>
<li><p><strong>规则网络</strong>：指平移对称性晶格，任何一个格点的近邻数目都相同。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220119-路由算法</title>
    <url>/2022/01/19/20220119-%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><p>路由算法是路由协议必须高效地提供其功能，尽量减少软件和应用的开销。路由器使用路由算法来找到到达目的地的最佳路由。</p>
<span id="more"></span>
<h4 id="1-传统路由算法"><a href="#1-传统路由算法" class="headerlink" title="1. 传统路由算法"></a>1. 传统路由算法</h4><ul>
<li><p><strong>分类：</strong>①总体式路由算法；②分散式路由算法；</p>
<ul>
<li><p>总体式（对应LS算法，链路状态）：每个路由器都拥有网络中所有其他路由器的全部信息以及网络的流量状态。</p>
<blockquote>
<p><strong>链路状态算法【短路径优先算法】：</strong>把路由信息散布到网络的每个节点，不过每个路由器只发送路由表中描述自己连接状态的部分；</p>
<p><strong>适合情况：</strong>网络规模较大时，链路状态路由选择更可取些。另外，链路状态协议能够为安全起见把机密信息隔离在特殊区域，或避开网上正在进行计算机辅助计算、多媒体通讯等拥挤区域。并且路由选择信息表在必要时进行交换而不是规律性地交换，这样可以减少网络上的信息流量。链路状态路由选择比距离向量路由选择需要更强的处理能力，它可以对路由选择过程提供更多的控制和对变化相应更快。路由选择可以基于避开拥塞区、线路的速度、线路的费用或各种优先级别。Dijkstra算法用于计算路由，根据如下：</p>
<ul>
<li>分组到达目的站经过的路由器数量（路由中继Hop），并且hop跳数越少越好；</li>
<li>局域网间传输线路的速度。有些路由使用低速异步链接，而另一些路由使用高速数字链路。</li>
<li>信息拥塞将造成延迟。如果一台工作站传送一个大文件，路由器可以通过不同的路径发送分组以避免交通阻塞。</li>
</ul>
</blockquote>
</li>
<li><p>分散式（对应DV算法，距离向量）：每个路由器只有与它直接相连的路由器的信息，没有网络中的每个路由器的信息。</p>
<blockquote>
<p><strong>距离向量算法【Bellman-Ford算法】：</strong>网络中每个路由器发送路由表的全部或部分，但只发给其邻居。距离向量路由选择协议的分组传送路由是根据到接收站的跳数或费用决定的，这些信息由各相邻的路由器提供。技术上通常都遵循Bellman-Ford算法。（一个路由器有几个端口，每个端口都有指定的价值，这些价值是由网络管理员设定的。用使用一条路线实际费用的多少，作为一种衡量手段表明一条路线比另一条好或坏。）通用距离向量路由选择协议由：RIP和IGRP。</p>
<p><strong>不适合情况</strong>：不适合于有几百个路由器的大型网络或经常要更新的网络。在大型网络中，表的更新过程可能过长，以至于最远的路由器的选择表不大可能与其他表同步更新。它告诉在网络中每个节点的最远和最近距离。在距离表中的这个信息是根据临近节点信息的改变实时更新的。</p>
</blockquote>
</li>
<li><p>链接状态算法到处发送较少的更新信息，距离向量算法只向相邻路由器发送较多的更新信息。</p>
</li>
</ul>
</li>
<li><p><strong>收敛：</strong>在最佳路径的判断上所有路由器达到一致的过程。当某个网络事件引起路由可用或不可用时，路由器就发出更新信息。路由更新信息遍及整个网络，引发重新计算最佳路径，最终达到所有路由器一致公认的最佳路径。收敛慢的路由算法会造成路径循环或网络中断。</p>
</li>
<li><p><strong>核心：</strong>路由选择算法。设计路由算法时需要考虑的技术要素有：</p>
<ul>
<li>选择最短路由还是最佳路由；</li>
<li>通信子网是采用虚电路操作方式还是采用数据报的操作方式；</li>
<li>采用分布式路由算法还是采用集中式路由算法；</li>
<li>考虑关于网络拓扑、流量和延迟等网络信息的来源；</li>
<li>确定采用静态路由还是动态路由；</li>
</ul>
</li>
<li><p><strong>各路由算法的区别点包括：</strong>静态与动态、单路径与多路径、平坦与分层、主机智能与路由器智能、域内与域间、链路状态与距离向量；</p>
<ul>
<li>静态路由选择：路由器可以依赖人工编程把选择的路径输进设备。</li>
<li>动态路由选择：依靠路由器收集网络信息和建立自己的路由表。路由器相互交换路由表，并且归并这些路由信息建立更新的路由表。从其他路由器上获得的信息，提供到网络上目的站点的路由终极数或与路径相关的费用。同时每个路由选择设备上的路由表，应该包含大体上一致的路由选择信息。</li>
<li></li>
</ul>
</li>
<li><p>metric是路由算法用以确定到达目的地的最佳路径的计量标准，如路径长度；</p>
</li>
<li><p><strong>路由选择协议：</strong>当两台非直接连接的计算机需要经过几个网络通信时，通常就需要路由器，路由器提供一种方法来开辟通过一个网状联结的路径。路由选择协议的任务是：为路由器提供他们建立通过网状网络最佳路径所需要的相互共享的路由信息。当一个计算机发送一个分组时，在网络上网络协议栈的每一层都附加一些信息给它。在接收方的对等层协议可以读出这些信息。这些信息类似于通信会话的某些部分。网络层的协议附加路由选择信息，这可能是通过一个网络的完整路径或是一些指示分组应该采用哪条路径的优先值、发送方添加的网络层信息只能由路由器或接收方的网络层协议读取。中继器和桥接器不能识别网络层信息，只能传送和转发分组。</p>
</li>
<li><p><strong>路由选择算法：</strong>一个路由器设备可能有两个或多个可以发送数据分组的端口。它必须有一张转发表为每一个端口标明一个特定地址。早期路由器不和其他路由器交换网络上有关路由器的信息，因此一个路由器通常沿着每条路径发送数据分组，分组充满网络，并且发送的一些分组在网络上无休止地循环。</p>
</li>
<li><p><strong>路由的费用：</strong>通常是根据传输介质确定的。最便宜的路径可能不是最快的，但是对某些类型的传输却更为可取。最常用的链路状态路由选择协议是优先开放最短路径（OSPF），它和OSI的中间系统到中间系统是类似的。OSPF路由选择表仅当在需要时更新，而不是定时更换。这有效地较少了通信流量和节省了网络带宽。通过网络的路径由上述标准选定。一个网络管理员可以根据信息传送的类型编制通过网络的路径。例如，当路线有较高数据传输率时，即使通过网络的那条路径有较多的HOP数也是可取的；此外对于不重要的信息将安排在低速低值的线路上传送。</p>
</li>
<li><p><strong>自治环境：</strong>一个区域是一些使用相同路由选择协议的主机和路由器的集合，它们使用相同的路由选择协议和由单一机构管理。</p>
</li>
<li><p><strong>内部/域内协议</strong></p>
</li>
<li><p><strong>外部/域间协议</strong></p>
</li>
</ul>
<h4 id="2-卫星网络路由"><a href="#2-卫星网络路由" class="headerlink" title="2. 卫星网络路由"></a>2. 卫星网络路由</h4><ul>
<li><p><strong>早期</strong>：快照技术，基于虚拟拓扑的集中式路由机制；</p>
</li>
<li><p><strong>改进算法：</strong></p>
<ul>
<li><p>由于卫星网络内部的星间相对位置通常相对固定，一部分工作提出基于虚拟节点的分布式路由机制。基于已知的星间相对位置的信息，根据星上存储的预先计算生成的映射表选择转发接口，或者邻居之间交换位置信息和移动方向信息，比较邻居距目的地址绝对距离得到下一条路由。</p>
<blockquote>
<ul>
<li>优点：避免了基于虚拟拓扑的集中式路由机制存在的路由表存储开销巨大的问题；</li>
<li>弊端：由于卫星高速运动，卫星与用户之间切换频繁，获取落地卫星标识会产生大量的位置更新开销。此外由于卫星位置具有时变性，部分解决方案需要邻居间定期交换状态信息。随着卫星星座规模的增大，邻居间消息交换愈发频繁，导致卫星网络中带宽资源浪费严重。</li>
</ul>
</blockquote>
</li>
<li><p>现有地面基于IP的分布式路由协议迁移应用能充分发挥地面互联网的优势，但是现有的分布式IP路由协议主要是针对地面互联网设计，其拓扑基本稳定，这导致协议对一体化网络链路连接关系高动态变化场景应对不足，路由频繁更新使协议可用性受到极大影响。相应的改进算法，尝试利用卫星周期运行规律，引入预测信息，优化一体化网络路由机制设计，如OSPF+、BGP+等。</p>
<blockquote>
<ul>
<li>缺点：规模增大使得需要预测的指标增多，对卫星存储能力和计算能力提出了更高的要求，频繁的消息交换也给卫星能耗带来更大挑战。</li>
</ul>
</blockquote>
</li>
<li><p>基于位置的天地一体化网络路由寻址机制：创新之处在于以下方面：</p>
<blockquote>
<ul>
<li>不需要通过获取邻居信息计算下一跳，仅 需要从IP地址中获取目的地址的位置信息来计算方位，由选择算法计算得到的卫星自身最优的接口直接进行数据分组转发。同时算法结合传统路由表查找机制的优势，提出星上临时路由表的概念，将分布式计算结果存储到路由表中，当卫星与目的地址相对位置发生改变时，更新临时路由表。临时路由表使LA-ISTN对于连续数据传输支持度更高。</li>
</ul>
</blockquote>
</li>
<li><p><strong>路由机制：</strong></p>
<ul>
<li><p>LA-ISTN：</p>
<blockquote>
<ul>
<li>算法1：首先查找临时路由表，若查找成功，将数据分组从路由表中记录的接口转发给目的用户；否则选择对应最小接接口方向角的转发接口，将数据分组从该接口转发给下一条邻居卫星节点。</li>
<li>由于单颗卫星的计算能力不足，卫星接口方向角的获得和计算开销对此类卫星网络压力大，因此引申出算法2；</li>
<li>算法2：利用星间邻居相对位置来选择转发接口——目的地址与卫星的相对方位根据目的IP地址中记录的位置信息计算得到。它将复杂的接口选择问题转化为选择轨内星间链路或轨间星间链路转发的问题。考虑不同维度轨间星间链路的长度有区别，在选择最优转发接口时：<ul>
<li>若目的地址相对当前卫星处于较高纬度，优先轨内转发；</li>
<li>若目的地址相对当前卫星处于较低纬度，优先轨间转发；</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>临时路由表：星上存储临时接入<strong>当前卫星的终端路由信息</strong>和<strong>LA-ISTN生成的路由表项</strong>。当卫星与目的地址的相对位置发生改变时，清除当前路由表项信息，以保证临时路由表中记录始终是有效的。</p>
</li>
</ul>
</li>
<li><p><strong>机理分析：</strong></p>
<ul>
<li>最后一跳寻址可达性分析：分布式位置路由算法存在不可达问题在于路由的最后一条。卫星覆盖区域重叠导致用户节点位于当前卫星覆盖范围内但并未接入当前卫星的情况发生。在LA-ISTN中，寻址机制将继续选取靠近目的位置的接口方向进行转发。</li>
<li>轨间链路断开及拼缝位置寻址可达性分析</li>
<li>开销分析</li>
<li>性能分析</li>
</ul>
</li>
</ul>
</li>
<li><p>《Loop-Free Hybrid Single-Path/Flooding Routing Algorithms with Guaranteed Delivery for Wireless Networks》</p>
</li>
<li><p><strong>想法</strong>：</p>
<ul>
<li>选择方向角最小的那个，但是不知道原因orz</li>
<li>compass routing, 选择与当前节点的夹角和当前节点和目的节点夹角最小的节点；</li>
<li>MFR (most forward within radius)</li>
<li>distance, progress, and direction-based approaches</li>
<li>蚁群算法：分布计算、信息正反馈、启发式搜索特征，本质是进化算法中的一种启发式全局优化算法。和传统的路由算法相较，该算法在网络路由中具有信息分布式性、动态性、随机性和异步性等特点，而这些特点正好能满足网络路由的需要。</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220120-蚁群算法</title>
    <url>/2022/01/20/20220120-%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="蚁群算法"><a href="#蚁群算法" class="headerlink" title="蚁群算法"></a>蚁群算法</h3><blockquote>
<p>蚁群算法具有分布计算、信息正反馈、启发式搜索特征，本质是进化算法中的一种启发式全局优化算法。蚁群算法应用广泛，如旅行商问题、指派问题、job-shop调度问题、车辆路径问题、图着色问题、网络路由问题等。和传统的路由算法相较，该算法在网络路由中具有信息分布式性、动态性、随机性和异步性等特点，而这些特点正好能满足网络路由的需要。</p>
</blockquote>
<span id="more"></span>
<h3 id="1-蚁群算法的特点"><a href="#1-蚁群算法的特点" class="headerlink" title="1. 蚁群算法的特点"></a>1. 蚁群算法的特点</h3><ul>
<li>高度结构化的组织：虽然蚂蚁的个体行为极其简单，但由个体组成的蚁群却构成高度结构化的社会组织，蚂蚁社会的成员有分工，有相互的通信和信息传递；</li>
<li>自然优化：蚁群在觅食过程中，在没有任何提示下总能找到从蚁巢到事物源之间的最短路径。当经过的路线上出现障碍物时，还能迅速找到新的最优路径；</li>
<li>信息正反馈：蚂蚁在寻找食物时，在其经过的路径上释放信息素（外激素）。蚂蚁基本没有视觉，但能在小范围内察觉同类散发的信息素的轨迹，由此来决定何去何从，并倾向于朝向信息素强度高的方向移动。由于采用正反馈机制，使得搜索过程不断收敛，最终逼近最优解；</li>
<li>自催化行为：某条路径上走过的蚂蚁越多，留下的信息素也越多（随时间蒸发一部分），后来蚂蚁选择该路径的概率也越高。</li>
<li>搜索过程采用分布式计算方式，多个个体同时进行并行计算，大大提高了算法的计算能力和运行效率；</li>
<li>启发式的概率搜索方式不容易陷入局部最优，易于找到全局最优解；</li>
</ul>
<h3 id="2-蚁群算法的基本思想"><a href="#2-蚁群算法的基本思想" class="headerlink" title="2. 蚁群算法的基本思想"></a>2. 蚁群算法的基本思想</h3><ul>
<li>首先根据具体问题设置多只蚂蚁，分头并行搜索；</li>
<li>每只蚂蚁完成一次周游后，在行进的路上释放信息素，信息素量与解的质量成正比；</li>
<li>蚂蚁路径的选择根据信息素强度大小（初始信息素设为相等），同时考虑两点之间的距离，采用随机的局部搜索策略。这使得距离较短的边上的信息素量较大，后来的蚂蚁选择该边的概率也较大；</li>
<li>每只蚂蚁只能走合法线路（经过城市1次且仅1次），为此设置禁忌表来控制；</li>
<li>所有蚂蚁都搜索完一次就是迭代一次，每迭代一次就对所有的边做一次信息素更新，原来的蚂蚁死掉，新的蚂蚁进行新一轮搜索；</li>
<li>更新信息素包括原有信息素的蒸发和经过路径上信息素的增加；</li>
<li>达到预定的迭代步数，或出现停滞现象（所有蚂蚁都选择同样的路径，解不再变化），则算法结束，以当前最优解作为问题的最优解；</li>
</ul>
<h4 id="3-需要关注的计算公式"><a href="#3-需要关注的计算公式" class="headerlink" title="3. 需要关注的计算公式"></a>3. 需要关注的计算公式</h4><ul>
<li>信息素的更新计算</li>
<li>蚂蚁的转移概率计算公式</li>
<li>具体实例说明：<a href="https://cloud.tencent.com/developer/article/1704718">https://cloud.tencent.com/developer/article/1704718</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220410-cKDTree</title>
    <url>/2022/04/10/20220410-cKDTree/</url>
    <content><![CDATA[<h3 id="cKDTree"><a href="#cKDTree" class="headerlink" title="cKDTree"></a>cKDTree</h3><blockquote>
<ul>
<li>KDTree：是查找大数据的最近邻居的快速方法；</li>
<li>作用：快速将GPS点位根据最邻近距离投影到最近路网（两千万点位在2min内完成匹配）；</li>
</ul>
</blockquote>
<span id="more"></span>
<h4 id="0-基本基础"><a href="#0-基本基础" class="headerlink" title="0. 基本基础"></a>0. 基本基础</h4><ul>
<li><strong>ARCGIS</strong></li>
<li><strong>空间索引：</strong>指依据空间对象的位置和形状或空间对象之间的某种空间关系按照一定顺序排列的一种数据结构，其中包含空间对象的概要信息，如对象的标识、外界矩形以及指向空间对象实体的指针。作为一种辅助性的空间数据结构，空间索引介于空间操作算法和空间对象之间，通过筛选，排除大量与特定操作无关的空间对象，从而提高空间操作的速度和效率。</li>
<li><strong>研究历程：</strong>当前数据搜索的一个关键问题是速度。提高速度的核心技术是空间索引。空间索引是由空间位置到空间对象的映射关系。但空间索引技术并不单是为了提高显示速度。其技术核心是：根据搜索条件，比如一个矩阵，迅速找到与该矩形相交的所有空间对象集合。当数据量巨大，矩形框相对于全图很小时，这个集合相对于全图数据集大为缩小，从而减少了后续的处理复杂度。</li>
<li>传统的空间索引一般是指对连续的地图进行网格化，从而将地图信息转化为矩阵信息进行有序存储，但网格化的问题是，如果网格分得过大，一个网格内会包含多条路段，因此即使可以快速定位到网格，依然还需要进行二次运算来判断最终的路段。考虑到目前计算机硬件能力足够，我们在进行网格化的时候可以进一步精细化，以存储换速度。因此，在此我们不再对路网进行网格索引，而直接对路段进行<strong>等距拆分为点</strong>。拆分完毕之后，一个路段便对应着多个点位，并共同构成了一个固定的路网空间索引表（路段ID，路段点经纬度，路段信息等）。而我们接下来要做的，就是<strong>找出每个GPS点位距离最近的路网空间点位</strong>，然后再将路网信息一并merge过来，即可完成路网的临近匹配了。之后我们的问题就转变为：<strong><font color='cornflowerblue'>给出A，B两个坐标矩阵，如何以最快的速度从A中找出距离B内每一个点最近的点位索引。</font></strong></li>
</ul>
<h4 id="1-KDTree"><a href="#1-KDTree" class="headerlink" title="1. KDTree"></a>1. KDTree</h4><ul>
<li>KDTree是一个非常高效的最邻近搜索算法，通过建立索引树来提高检索速度。在Python中使用也非常简单，直接调用<code>scipy.spatial</code>即可。但KDTree包的问题在于，其本身是不支持以经纬度球面距离为metric来进行搜索的。而如果我们不进行经纬度转化，直接调用KDTree的话，会由于计算出的距离误差而导致我们的搜索出现偏差。</li>
<li>参考矩阵：相当于我们的路网空间索引矩阵；</li>
<li>对比矩阵：相当于我们的GPS点位矩阵；</li>
</ul>
<h4 id="2-具体示例"><a href="#2-具体示例" class="headerlink" title="2. 具体示例"></a>2. 具体示例</h4><blockquote>
<p>给定数据集A（包含1,000,000条数据），求集合X（包含10,000个点）中的每个点的最邻近点，返回应该是10,000个索引。</p>
</blockquote>
<ul>
<li><p><code>cdist</code>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = time.time()</span><br><span class="line">nn = np.array([])</span><br><span class="line">jump = <span class="number">1000</span></span><br><span class="line">nloop = np.ceil(A.shape[<span class="number">0</span>]/jump).astypr(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(nloop):</span><br><span class="line">    temp = cdist(X, A[ii*jump : (ii+<span class="number">1</span>)*jump])</span><br><span class="line">    nn = np.append(nn, np.argmin(temp, axis = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Elapsed time: &#x27;</span>, time.time() - t)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cKDTree</code>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = time.time()</span><br><span class="line">tree = cKDTree(X)</span><br><span class="line">nn = tree.query(A, <span class="number">1</span>, n_jobs=<span class="number">4</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Elapsed time: &#x27;</span>, time.time() - t)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-KD-Tree"><a href="#3-KD-Tree" class="headerlink" title="3. KD-Tree"></a>3. KD-Tree</h4><ul>
<li><strong>应用举例：</strong>SIFT算法中做特征点匹配时利用到KDTree。特征点匹配实际上就是通过距离函数在高维矢量之间进行相似性检索的问题。</li>
<li><strong>索引结构中相似性查询：</strong><ul>
<li>范围查询：给定查询点和查询距离的阈值，从数据集中找出所有与查询点距离小于阈值的数据；</li>
<li>K近邻查询：给定查询点和正整数K，从数据集中找出距离查询点最近的K个数据；</li>
</ul>
</li>
<li><strong>特征匹配算子：</strong><ul>
<li>线性扫描法：将数据集中的点与查询点逐一进行距离比较；</li>
<li>建立数据索引，然后再进行快速匹配：实际数据一般都会呈现出簇状的聚类形态，通过设计有效的索引结构可以大大加快检索的速度。</li>
</ul>
</li>
</ul>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul>
<li><p><a href="http://t.zoukankan.com/wellp-p-8552774.html">Kdtree原理以及 vs Octree</a></p>
</li>
<li><p><a href="https://www.lmlphp.com/user/980/article/item/22702/">KDTree学习笔记</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/53992405">https://zhuanlan.zhihu.com/p/53992405</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220404-dataloader深入剖析</title>
    <url>/2022/04/04/20220404-dataloader%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h3 id="DataLoader深入剖析"><a href="#DataLoader深入剖析" class="headerlink" title="DataLoader深入剖析"></a>DataLoader深入剖析</h3><p>DataLoader本质是一个可迭代对象：</p>
<blockquote>
<ul>
<li><p>使用<code>iter()</code>访问，不能使用<code>next()</code>访问</p>
</li>
<li><p>使用<code>iter(dataloader)</code>返回的是一个迭代器，然后可以使用<code>next()</code>访问</p>
</li>
<li>也可以使用<code>for inputs, labels in dataloaders</code>进行可迭代对象的访问</li>
<li>一般我们实现一个dataset对象，传入到dataloader中，然后内部使用<code>yeild</code>返回每一个batch的数据；</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>20220416-Mininet入门学习</title>
    <url>/2022/04/16/20220416-Mininet%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Mininet入门学习"><a href="#Mininet入门学习" class="headerlink" title="Mininet入门学习"></a>Mininet入门学习</h3><blockquote>
<p>基本介绍，参见：<a href="https://github.com/mininet/mininet/wiki/Introduction-to-Mininet#what">官方说明</a></p>
</blockquote>
<span id="more"></span>
<h4 id="1-Mininet基本操作"><a href="#1-Mininet基本操作" class="headerlink" title="1. Mininet基本操作"></a>1. Mininet基本操作</h4><ul>
<li>Creating Topologies</li>
<li>Setting Performance Parameters</li>
<li>Running Programs in Hosts</li>
<li>New: <code>popen()</code>/<code>pexec()</code> interface</li>
<li>Host Configuration Methods</li>
<li>Naming in Mininet</li>
<li>Customizing mn using —custom files</li>
</ul>
<h4 id="2-Host-Configuraton-Methods"><a href="#2-Host-Configuraton-Methods" class="headerlink" title="2. Host Configuraton Methods"></a>2. Host Configuraton Methods</h4><ul>
<li><code>IP()</code>：return IP address of a host or specific interface.</li>
<li><code>MAC()</code>：return MAC address of a host or specific interface.</li>
<li><code>setARP()</code>：add a static ARP entry to a host’s ARP cache.</li>
<li><code>setIP()</code>：set the IP address for a host or specific interface.</li>
<li><code>setMAC()</code>：set the MAC address for a host or specific interface.</li>
</ul>
<h4 id="3-Customizing-mn-using-custom-files"><a href="#3-Customizing-mn-using-custom-files" class="headerlink" title="3. Customizing mn using --custom files"></a>3. Customizing <code>mn</code> using <code>--custom</code> files</h4><h4 id="4-Understanding-the-Mininet-API"><a href="#4-Understanding-the-Mininet-API" class="headerlink" title="4. Understanding the Mininet API"></a>4. Understanding the Mininet API</h4><ul>
<li><p>可以将Mininet的API划分为以下3个主要层级：</p>
<ul>
<li><p><strong>Low-level API：</strong> consists of the base node and link classes (such as <code>Host</code>, <code>Switch</code>, and <code>Link</code> and their subclasses) . <strong>Low-level API: nodes and links</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h1 = Host( <span class="string">&#x27;h1&#x27;</span> )                                 </span><br><span class="line">h2 = Host( <span class="string">&#x27;h2&#x27;</span> )                             </span><br><span class="line">s1 = OVSSwitch( <span class="string">&#x27;s1&#x27;</span>, inNamespace=<span class="literal">False</span> )                             </span><br><span class="line">c0 = Controller( <span class="string">&#x27;c0&#x27;</span>, inNamespace=<span class="literal">False</span> )      </span><br><span class="line">Link( h1, s1 )     </span><br><span class="line">Link( h2, s1 )                                 </span><br><span class="line">h1.setIP( <span class="string">&#x27;10.1/8&#x27;</span> )                                 </span><br><span class="line">h2.setIP( <span class="string">&#x27;10.2/8&#x27;</span> )                           </span><br><span class="line">c0.start()                           </span><br><span class="line">s1.start( [ c0 ] )                                     </span><br><span class="line"><span class="built_in">print</span>( h1.cmd( <span class="string">&#x27;ping -c1&#x27;</span>, h2.IP() ) )</span><br><span class="line">s1.stop()                            </span><br><span class="line">c0.stop() </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Mid-level API：</strong>adds the <code>Mininet</code> object which serves as a container for nodes and links. (such as <code>addHost()</code>, <code>addSwitch()</code>, and <code>addLink()</code>) , as well as network configuration, startup and shutdown (notably <code>start()</code> and <code>stop()</code>). <strong>Mid-level API: Network object</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = Mininet()</span><br><span class="line">h1 = net.addHost( <span class="string">&#x27;h1&#x27;</span> )</span><br><span class="line">h2 = net.addHost( <span class="string">&#x27;h2&#x27;</span> )</span><br><span class="line">s1 = net.addSwitch( <span class="string">&#x27;s1&#x27;</span> )</span><br><span class="line">c0 = net.addController( <span class="string">&#x27;c0&#x27;</span> )</span><br><span class="line">net.addLink( h1, s1 )</span><br><span class="line">net.addLink( h2, s1 )</span><br><span class="line">net.start()</span><br><span class="line"><span class="built_in">print</span>( h1.cmd( <span class="string">&#x27;ping -c1&#x27;</span>, h2.IP() ) )</span><br><span class="line">CLI( net )</span><br><span class="line">net.stop()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>High-level API：</strong>adds a topology template abstraction.  The <code>Topo</code> class, which provides the ability to create reusable, parametrized topology templates. These templates can be passed to the <code>mn</code> command (via the <code>--custom</code> option) and used from the command line. <strong>High-level API: Topology templates</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleSwitchTopo</span>(<span class="params"> Topo </span>):</span>                                     </span><br><span class="line">    <span class="string">&quot;Single Switch Topology&quot;</span>                        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params"> self, count=<span class="number">1</span> </span>):</span>                 </span><br><span class="line">        hosts = [ self.addHost( <span class="string">&#x27;h%d&#x27;</span> % i )                       </span><br><span class="line">                  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">1</span>, count + <span class="number">1</span> ) ]                </span><br><span class="line">        s1 = self.addSwitch( <span class="string">&#x27;s1&#x27;</span> )    </span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> hosts:                   </span><br><span class="line">            self.addLink( h, s1 )                               </span><br><span class="line"></span><br><span class="line">net = Mininet( topo=SingleSwitchTopo( <span class="number">3</span> ) )                 </span><br><span class="line">net.start()       </span><br><span class="line">CLI( net )                                        </span><br><span class="line">net.stop()   </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="5-Measuring-Performance"><a href="#5-Measuring-Performance" class="headerlink" title="5. Measuring Performance"></a>5. Measuring Performance</h4><ul>
<li>Bandwidth (<code>bwm-ng</code>, <code>ethstats</code>)</li>
<li>Latency (use <code>ping</code>)</li>
<li>Queues (use <code>tc</code> included in <code>monitor.py</code>)</li>
<li>TCP <code>CWND</code> statistics (<code>tcp_probe</code>, maybe we should add it to <code>monitor.py</code>)</li>
<li>CPU usage (global: <code>top</code>, or per-container <code>cpuacct</code>)</li>
</ul>
<h4 id="6-Mininet原理"><a href="#6-Mininet原理" class="headerlink" title="6. Mininet原理"></a>6. Mininet原理</h4><ul>
<li><strong>组成部分</strong>：<ul>
<li>Isolated Hosts</li>
<li>Emulated Links</li>
<li>Emulated Switches: default <strong>Linux bridge</strong> or <strong>Open vSwitch</strong> running in kernel model to switch packets across interfaces.</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220419-ifconfig</title>
    <url>/2022/04/19/20220419-ifconfig/</url>
    <content><![CDATA[<h3 id="ifconfig解析"><a href="#ifconfig解析" class="headerlink" title="ifconfig解析"></a>ifconfig解析</h3><h4 id="0-具体示例说明"><a href="#0-具体示例说明" class="headerlink" title="0. 具体示例说明"></a>0. 具体示例说明</h4><ul>
<li><p><code>ifconfig</code>用于显示网络设备信息；</p>
<span id="more"></span>
<p><strong>执行命令后显示：</strong></p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ifconfig</span>        </span><br><span class="line">eth0   Link encap:Ethernet HWaddr 00:50:56:0A:0B:0C </span><br><span class="line">     inet addr:192.168.0.3 Bcast:192.168.0.255 Mask:255.255.255.0</span><br><span class="line">     inet6 addr: fe80::250:56ff:fe0a:b0c/64 Scope:Link</span><br><span class="line">     UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</span><br><span class="line">     RX packets:172220 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">     TX packets:132379 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">     collisions:0 txqueuelen:1000 </span><br><span class="line">     RX bytes:87101880 (83.0 MiB) TX bytes:41576123 (39.6 MiB)</span><br><span class="line">     Interrupt:185 Base address:0x2024 </span><br><span class="line"></span><br><span class="line">lo    Link encap:Local Loopback </span><br><span class="line">     inet addr:127.0.0.1 Mask:255.0.0.0</span><br><span class="line">     inet6 addr: ::1/128 Scope:Host</span><br><span class="line">     UP LOOPBACK RUNNING MTU:16436 Metric:1</span><br><span class="line">     RX packets:2022 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">     TX packets:2022 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">     collisions:0 txqueuelen:0 </span><br><span class="line">     RX bytes:2459063 (2.3 MiB) TX bytes:2459063 (2.3 MiB)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>分析说明：</strong></p>
<blockquote>
<ul>
<li><code>eth0   Link encap:Ethernet HWaddr 00:50:56:0A:0B:0C</code><ul>
<li><code>eth0</code>：网卡名称；</li>
<li><code>Link encap:Ethernet</code>：连接类型，这里是以太网（Ethernet）；</li>
<li><code>HWaddr 00:50:56:0A:0B:0C</code>：网卡物理地址（MAC地址）；</li>
</ul>
</li>
<li><code>inet addr:192.168.0.3 Bcast:192.168.0.255 Mask:255.255.255.0</code>：<ul>
<li><code>inet addr</code>：网卡的IPv4地址；</li>
<li><code>Bcast</code>：广播地址；</li>
<li><code>Mask</code>：子网掩码；</li>
</ul>
</li>
<li><code>inet6 addr: fe80::250:56ff:fe0a:b0c/64 Scope:Link</code>：<ul>
<li><code>inet6 addr</code>：网卡的IvP6地址；</li>
</ul>
</li>
<li><code>UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1</code>：<ul>
<li><code>UP</code>：表明接口已启用；</li>
<li><code>BROADCAST</code>：表明主机支持广播；</li>
<li><code>RUNNING</code>：表明接口在工作中；</li>
<li><code>MULTICAST</code>：表明主机支持多播；</li>
<li><code>MTU:1500</code>：最大传输单元为1500字节；</li>
</ul>
</li>
<li><code>RX packets:172220 errors:0 dropped:0 overruns:0 frame:0</code>：<ul>
<li><code>RX packets</code>：接收到的正确数据包数；</li>
<li><code>RX errors</code>：接收到的产生错误的数据包数；</li>
<li><code>RX dropped</code>：接收到的丢弃的数据包数；</li>
<li><code>RX overruns</code>：接收到的由于速度过快而丢失的数据包数；</li>
<li><code>RX frame</code>：接收到的发生<code>frame</code>错误而丢失的数据包数；</li>
</ul>
</li>
<li><code>TX packets:132379 errors:0 dropped:0 overruns:0 carrier:0</code>：<ul>
<li><code>TX packets</code>：发送时正确数据包数；</li>
<li><code>TX errors</code>：发送时产生错误的数据包数；</li>
<li><code>TX dropped</code>：发送时的丢弃的数据包数；</li>
<li><code>TX overruns</code>：发送时由于速度过快而丢失的数据包数；</li>
<li><code>TX carrier</code>：发送时发生<code>carrier</code>错误而丢失的数据包数；</li>
</ul>
</li>
<li><code>collisions:0 txqueuelen:1000</code>：<ul>
<li><code>collisions</code>：冲突信息包的数目；</li>
<li><code>txqueuelen</code>：网卡设置的传送队列长度；</li>
</ul>
</li>
<li><code>RX bytes:87101880 (83.0 MiB) TX bytes:41576123 (39.6 MiB)</code>：<ul>
<li><code>RX bytes</code>：接收的数据量；</li>
<li><code>TX bytes</code>：发送的数据量；</li>
</ul>
</li>
<li><code>Interrupt:185 Base address:0x2024</code>：</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="1-命令实例"><a href="#1-命令实例" class="headerlink" title="1. 命令实例"></a>1. 命令实例</h4><ul>
<li><p><code>ifconfig</code>：显示激活的网卡信息；</p>
</li>
<li><p><code>ifconfig -a</code>：显示所有的网卡信息；</p>
</li>
<li><p><code>ifconfig -s</code>：显示简要的网卡信息；</p>
</li>
<li><p><code>ifconfig eth0 down</code>或<code>ifdown eth0</code>：关闭网卡；</p>
</li>
<li><p><code>ifconfig eth0 up</code>或<code>ifup eth0</code>：启动网卡；</p>
</li>
<li><p>为网卡配置和删除IPv6地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 add 3ffe:3240:800:1005::2/64</span><br><span class="line">ifconfig eth0 del 3ffe:3240:800:1005::2/64</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>修改MAC地址：<code>ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE</code>；</p>
</li>
<li><p>配置IP地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置ip地址</span></span><br><span class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 配置ip地址和子网掩码</span></span><br><span class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span> netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 配置ip地址、子网掩码和广播地址</span></span><br><span class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span> netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> broadcast <span class="number">192.168</span><span class="number">.1</span><span class="number">.255</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>单网卡添加多个IP地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0:0 192.168.1.100 netmask 255.255.255.0 up</span><br><span class="line">ifconfig eth0:1 192.168.2.100 netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除IP地址：<code>ifconfig eth0 del 192.168.1.100</code>；</p>
</li>
<li><p>启动和关闭ARP协议：<code>ifconfig eth0 arp</code>和<code>ifconfig eth0 -arp</code>；</p>
</li>
<li><p>设置最大传输单元：<code>ifconfig eth0 mtu 1500</code>；</p>
</li>
<li><p>启用和关闭网卡的promiscuous模式：<code>ifconfig eth0 promisc</code>和<code>ifconfig eth0 -promisc</code>;</p>
</li>
<li><p>启用和关闭网卡的多播模式：<code>ifconfig eth0 allmulti</code>和<code>ifconfig eth0 -allmulti</code>;</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20220905-WebRTC</title>
    <url>/2022/09/05/20220905-WebRTC/</url>
    <content><![CDATA[<h3 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h3><blockquote>
<p>WebRTC(Web Real-Time Communication)是一个可以用在视频聊天、音频聊天或P2P文件分享Web App中的API。</p>
</blockquote>
<p>WebRTC是一个可以在Web程序中实现音频，视频和数据的实时通信的开源项目。在实时通信中，音视频的采集和处理是一个很复杂的过程。比如音视频流的编解码、降噪和回声消除等，但是在WebRTC中，这一切都交由浏览器的底层封装来完成。我们可以直接拿到优化后的媒体流，然后在其输出到本地屏幕和扬声器，或者转发给其对等端。长话短说，就是一个<strong>支持网页浏览器进行实时语音对话、视频对话、数据传输的API</strong>。</p>
<ol>
<li>WebRTC已经实现了对于实时通信，免插件音视频数据传输的标准制定，需求是：<ul>
<li>许多网络服务已经使用了RTC，但是需要下载，本地应用或者是插件；</li>
<li>下载安装升级插件是复杂的，可能出错的；</li>
<li>插件可能很难部署、调试、故障排除等；</li>
<li>插件可能需要技术授权，复杂集成和昂贵的技术；</li>
</ul>
</li>
<li>因此WebRTC项目的指导原则是：API应该是开源的，免费的，标准化的，浏览器内置的，比现有技术更高效的；</li>
<li>WebRTC有3个模块：<ul>
<li>Voice Engine(音频引擎)<ul>
<li>voice engine包含iSAC/iLBC Codec（音频编解码器，前者是针对宽带和超宽带，后者是针对窄带）；</li>
<li>netEQ for voice(处理网络抖动和语音包丢失)；</li>
<li>Echo Canceler(回声消除器)/noise reduction(噪声抑制)；</li>
</ul>
</li>
<li>NetEQ Engine(视频引擎)<ul>
<li>VP8 Codec（视频图像编解码器）；</li>
<li>Video jitter buffer（视频抖动缓冲器、处理视频抖动和视频信息包丢失）；</li>
<li>Image enhancements（图像质量增强）；</li>
</ul>
</li>
<li>Transport(数据传输)<ul>
<li>SRTP（安全的实时传输协议，用以音视频流传输）；</li>
<li>Multiplexing（多路复用）；</li>
<li>P2P, STUN+TURN+ICE（用于NAT网络和防火墙穿越的）；</li>
<li>除此之外，安全传输可能还会用到DTLS（数据报安全传输），用于加密传输和密钥协商；</li>
<li>整个WebRTC通信是基于UDP的；</li>
</ul>
</li>
</ul>
</li>
<li>核心组件<ul>
<li>音视频引擎：OPUS、VP8/VP9、H264</li>
<li>传输层协议：底层传输协议为UDP</li>
<li>媒体协议：SRTP/SCTP</li>
<li>数据协议：DTLS/SCTP</li>
<li>P2P内网穿透：STUN/TURN/ICE/Trickle ICE;</li>
<li>信令与SDP协商：HTTP/WebSocket/SIP/Offer Answer模型；</li>
</ul>
</li>
<li>NAT和NAT穿透<ul>
<li>NAT即网络地址转换，就是替换IP报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP转换为出口的IP地址提供公网可达以及和上层协议的连接能力；</li>
<li>NAT的分类：<ul>
<li>静态NAT：将单个私有IP地址与单个公共地址映射，即将私有IP地址转换为公共IP地址；</li>
<li>动态NAT：多个专用IP地址映射到公用IP地址池。当我们知道固定用户想要在给定的时间点访问Internet的数量时，将使用它；</li>
<li>PAT(NAT重载)：使用NAT重载可以将需要本地（专用）IP地址转换为单个公用IP地址。端口号用于区分流量，即哪个流量属于哪个IP地址。这是最常用的方法，因为它具有成本效益，因为仅使用一个真实的全局（公共）IP地址就可以将数千个用户连接到Internet.</li>
</ul>
</li>
</ul>
</li>
<li>STUN协议（Simple traversal of UDP over NAT protocol）</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>20220917-协议基础概念</title>
    <url>/2022/09/17/20220917-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="协议基础概念"><a href="#协议基础概念" class="headerlink" title="协议基础概念"></a>协议基础概念</h3><ol>
<li><p><strong>socket</strong>：</p>
<ul>
<li><strong>定义</strong>：网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。通常也称作”套接字“，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。</li>
<li><strong>本质</strong>：编程接口API，对TCP/IP的封装。提供可供程序员做网络开发所用的接口；</li>
<li><strong>举例</strong>：socket像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220V交流电，有的提供110V交流电，有的则提供有线电视节目。客户软件将插头插到不同编号的插座，就可以得到不同的服务。</li>
</ul>
</li>
<li><p><strong>TCP/IP和HTTP协议的关系</strong>：</p>
<ul>
<li><strong>TCP/IP协议</strong>：传输层协议，主要解决数据如何在网络中传输；</li>
<li><strong>HTTP协议</strong>：应用层协议，主要解决如何包装数据；</li>
<li><strong>举例1</strong>：我们在传输数据时，可以只使用传输层TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。如果想要使传输的数据有意义，则必须使用到应用层协议。</li>
<li><strong>举例2</strong>：WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</li>
</ul>
</li>
<li><p><strong>hook</strong>：</p>
<ul>
<li><strong>定义</strong>：指程序A在程序B里埋入的一段代码。当程序B运行到某种特定状态，或者某个特定条件成立，就会调用A埋入的那段代码。</li>
<li><strong>意义</strong>：一般来说程序B希望把一些定制能力开放给用户或者第三方的开发者。</li>
<li><strong>举例</strong>：例如github上有很多git repo，每个repo都有很多人提交代码，而且很多时候这些人之间互相不认识。假如我希望我的某个repo，只要有人提交了代码就自动运行一个测试程序，然后把测试结果发给我，这件事github自己要做就很不现实，因为它不知道我想如何测试，也不知道我想根据测试结果做什么，这时候 GitHub 的解决方案就是设计一个 <em>hook API</em>，允许我写一个“钩子函数（<em>hook</em>）”，并在我的 repo 的 “收到新 commit” 这个 “事件（<em>event</em>）” 上 “注册（<em>register</em>）” 这个钩子函数，以后 GitHub 只要收到该 repo 的 commit 就会触发这个钩子函数，执行我写的代码，我想做什么就我自己控制了。GitHub 事实上确实有这个功能（实际上是 git 底层就支持的），提供了 commit 前后的钩子接口，commit 前的钩子里你甚至可以根据运行情况决定是不是直接拒绝这个 commit。还有一种情况，钩子的接口不是程序 B 自己提供的，而是操作系统提供的机制，甚至是黑客强行在程序 B 中注入的，这就涉及到一些特定技术了，在特定环境下也是能做到的。不过，好孩子不干这个 ^_^</li>
</ul>
</li>
<li><p><strong>MPLS</strong>：</p>
<ul>
<li><strong>本质</strong>：一种隧道技术，在一定程度山更可以保证信息传输的安全性；</li>
<li><strong>体系结构</strong>：<ul>
<li>控制平面：无连接的，主要功能是负责标签的分配、LFIB的建立、LSP的建立、拆除等；</li>
<li>转发/数据平面：面向连接的，对IP包进行标签的添加和删除，同时依据标签转发表对收到的分组进行转发；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>平滑重启（graceful restart）</strong>:（<a href="http://www.h3c.com/cn/d_200911/655332_97665_0.htm">参考</a>）</p>
<ul>
<li><p><strong>定义</strong>：在主备切换或协议重启时保证转发业务不中断的机制。</p>
</li>
<li><p><strong>高可靠性（HA, High Availability）技术</strong>：HA是一整套综合技术，主要包括冗余容错、链路保证、节点故障修复及流量工程。其中，GR是一种冗余容错技术，目前已经被广泛的使用在主备切换和系统升级方面，以保证关键业务的不间断转发。</p>
</li>
<li><p><strong>前提</strong>：</p>
<ul>
<li>仅适用于带双主控、线卡具有独立处理器的硬件平台；</li>
<li>GR用于软件或硬件错误导致Active RP重起或Active RP失效；或者管理员的主备切换命令。</li>
</ul>
</li>
<li><p><strong>传统技术和GR技术的比较</strong>：</p>
<ul>
<li><p><strong>传统主备切换时造成的网络问题</strong>：</p>
<p><img src="https://res.h3c.com/cn/200911/18/20091118_878346_image001_655332_97665_0.png" alt="OSPF GR"></p>
</li>
<li><p><strong>采用GR技术解决了主备切换时造成的网络问题</strong>：</p>
<p><img src="https://res.h3c.com/cn/200911/18/20091118_878347_image002_655332_97665_0.png" alt="OSPF GR2"></p>
</li>
<li><p><strong><font color='red'>注意</font></strong>：如果在R1在GR的过程中，网络拓扑发生了变化，那么可能导致短暂的路由环路或路由黑洞。对于这个问题的处理方法，目前不同厂商的实现略有不同。与业务中断的危害相比较，是否可以容忍可能出现的短暂的路由环路和路由黑洞，对这个问题的不同观点决定了在具体实现上的不同。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>网络流量工程</strong>：</p>
<ul>
<li><strong>定义</strong>：根据各种数据业务流量的特性选取传输路径的处理过程。用于平衡网络中不同交换机、路由器以及链路之间的负载；</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>20220917-bird源码剖析（1）</title>
    <url>/2022/09/17/20220917-bird%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h3 id="bird源码剖析（1）"><a href="#bird源码剖析（1）" class="headerlink" title="bird源码剖析（1）"></a>bird源码剖析（1）</h3><ol>
<li>使用bird主要是通过读取bird.conf文件进行协议相关配置；</li>
<li>通过<code>configure.ac</code>文件，设置<code>CONFIG_FILE</code>变量为配置文件；</li>
<li><code>autoconf</code>将<code>configure.ac</code>中的宏展开，生成configure脚本；</li>
<li>【中间过程】</li>
<li>在<code>conf/conf.c</code>文件中通过<code>config_parse</code>函数进行语法解析；</li>
<li><p><code>sysdep/unix/main.c</code>文件分析：</p>
<ul>
<li>首先调用<code>parse_args</code>函数对配置文件解析(解析指定路径，无指定则选择默认配置)；</li>
<li>初始化操作，包括：<code>log_switch()</code>, <code>random_init()</code>,  <code>net_init()</code>, <code>resource_init()</code>, <code>timer_init()</code>, <code>olock_init()</code>, <code>io_init()</code>, <code>rt_init()</code>,<code>if_init()</code>；</li>
<li>设置log文件、随机初始化、网络、资源（pool）、等相关初始化配置；</li>
</ul>
</li>
<li><p><strong>核心文件夹</strong>：</p>
<ul>
<li><code>filter</code>：过滤器相关；</li>
<li><code>lib</code>：底层实现相关；<ul>
<li><code>lib/birdlib.h</code>：包含编译bird-gdb.py；</li>
</ul>
</li>
<li><code>nest</code>：BIRD核心相关；</li>
<li><code>proto</code>：协议相关；</li>
<li><code>sysdep</code>：glibc系统相关；</li>
<li><code>test</code>：暂未了解【猜测是用来debug的，里面包含了gdb等】；</li>
</ul>
</li>
<li><p><strong>其他知识点</strong>：</p>
<ul>
<li><p><code>.Y（Yet Another Compiler Compiler）</code>是Unix/Linux上一个用来生成编译器的编译器。yacc生成的编译器主要是用C语言写成的语法解析器（Parser），需要与词法解析器Lex一起使用，再把两部份产生出来的C程序一并编译。</p>
</li>
<li><p><code>.m4</code>文件：M4实际上是一种编程语言，后缀是.m4,说明这个文件是使用.m4写的，说的专业一点，这实际上就是一个通用宏处理器。 它经常被用来生成Makefile的脚本语言来使用。</p>
</li>
<li><p><code>toml</code>文件：配置文件，一种非常基础的文件格式。</p>
</li>
<li><p><code>distribution</code>(often abbreviated as <code>distro</code>)；</p>
</li>
<li><p><code>misc</code>文件夹：contains miscellaneous file types that do not fit within other categories.</p>
</li>
<li><p><code>sysdep</code>文件夹：（在Linux源码中是<code>/arch</code>，在<code>glibc</code>中是<code>/sysdep</code>）</p>
</li>
<li><p><code>glibc</code>是GNU发布的libc库，即c运行库。glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其他一些必要功能服务的是心啊。</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/31496865">glibc源码分析（1）系统调用</a></li>
</ul>
</li>
<li><p><code>stdarg.h</code>: a header in the C standard library of the C programming language that allows functions to accept an indefinite number of arguments.</p>
</li>
<li><p><code>···</code>用法：可变参数函数是可以采用可变数量的参数并用省略号代替最后一个参数声明的函数。例如：<code>static void bt_log_overall_result(int result, const char *fmt, ...)</code>。</p>
<ul>
<li><strong>意义</strong>：max函数之所以看起来简单是因为其可变参数表的长度是已知的（通过num参数传入），且可变参数表中参数的类型也是已知的（都为int型）。然而，printf函数则没有这么幸运。首先，printf函数可变参数的个数不能轻易的得到，而可变参数的类型也不是固定的，需由格式字符串进行识别（由%f、%d、%s等确定），因此则涉及到可变参数表的更复杂应用。</li>
</ul>
</li>
<li><p><code>asciz</code>：编译相关；</p>
</li>
<li><p><code>ISP</code>：互联网服务提供商，如电信、网通等；</p>
</li>
<li><p><strong>Linux Kernel Netlink Route Syncer</strong>：</p>
<ul>
<li>netlink套接字是用以实现用户进程与内核进程通信的一种特殊的进程间通信（IPC），也是网络应用程序与内核通信的最常用的接口；</li>
<li>netlink是一种特殊的socket，它是Linux所特有的，类似于BSD中的AF_ROUTE，但远比其功能强大，目前在Linux内核中使用netlink进行应用与内核通信的应用很多；</li>
</ul>
</li>
<li><p>GNU的autoconf可以用来生成makefile。一个GNU程序的编写，需要autoscan, aclocal, autoconf和automake这四个工具；</p>
</li>
<li><p>GNU软件安装的三部曲是：<code>./configure</code>, <code>make</code>, <code>make install</code>；</p>
<ul>
<li><code>./configure</code>根据autoconf， aclocal等工具生成一个makefile文件。检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。</li>
<li><code>make</code>从Makefile中读取指令，然后编译；</li>
<li><code>make install</code>是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</li>
</ul>
</li>
<li><p>守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种函数或等待某些发生的事件。守护进程最重要的特性是后台运行。其次，守护进程必须与其运行前的环境隔离开来（这些环境包括未关闭的文件描述符、控制终端、会话和进程组、工作目录以及文件的创建掩模等）。这些环境通常是守护进程从执行它地方父进程中集成下来的。最后，守护进程的启动方式有其特殊之处。它可以在linux系统启动时从启动脚本<code>/etc/rc.d</code>中启动，可以由作业规划进程crond启动，还可以由用户终端执行。</p>
</li>
<li><p><strong><font color='cornflowerblue'>为避免挂起控制终端将Daemon放入后台执行，相应的解决方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。</font></strong></p>
</li>
<li><p><strong>C使用：</strong></p>
<ul>
<li><p><code>read()</code>用于读取打开文件的内容，返回实际读取的字节数；</p>
</li>
<li><p><code>getgrnam()</code>用于逐一搜索参数指定的组名称，找到时便将改组的数据以group结构返回；</p>
</li>
<li><p><code>getgrgid()</code>用于根据参数gid指定的组识别码逐一搜索组文件，找到时便将该组的数据以group结构返回；</p>
</li>
<li><p><code>getopt()</code>函数用于解析命令行选项，可用来捕获选项（如<code>-c</code>, <code>-v</code>等），在<code>sysdep/unix/main.c</code>中<code>optstring = bc:dD:ps:P:u:g:flRh</code>；</p>
<blockquote>
<p><code>a:b:cd::e</code>，这就是一个选项字符串。对应到命令行就是-a ,-b ,-c ,-d, -e 。冒号又是什么呢？ 冒号表示参数，一个冒号就表示这个选项后面必须带有参数（没有带参数会报错哦），但是这个参数可以和选项连在一起写，也可以用空格隔开，比如-a123 和-a  123（中间有空格） 都表示123是-a的参数；两个冒号的就表示这个选项的参数是可选的，即可以有参数，也可以没有参数，但要注意有参数时，参数与选项之间不能有空格（有空格会报错的哦），这一点和一个冒号时是有区别的。</p>
</blockquote>
</li>
<li><p><code>setsid()</code>的作用：（1）新建一个对话；（2）新建进程组；</p>
</li>
<li><p><code>strrchr(str, c)</code>：查找str中最后一次出现字符的位置，并返回从字符串中的这个位置起，直到字符串结束的所有字符；</p>
</li>
<li><p><strong>每个打开的文件描述符（fd标志）在进程表中都有自己的文件表项。</strong><code>dup()</code>函数被调用时，内核在进程中创建一个新的文件描述符，此描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。</p>
</li>
<li><p><code>pthread_self()</code>：获得自身线程标识。</p>
</li>
<li><p><code>pthread_create()</code>：创建线程调用。</p>
</li>
<li><p><code>va_start(va_list ap, last_arg)</code>：将初始化ap变量，与<code>va_arg</code>和<code>va_end</code>宏是一起使用的，<code>last_arg</code>是最后一个传递给函数的已知的固定参数，即省略号之前的参数。</p>
</li>
<li><p><code>ftrubcate(int fd, off_t length)</code>：改变文件大小，即会将参数fd指定的文件大小改为参数length指定的大小。</p>
</li>
<li><p>在头文件中使用<code>#ifdef</code>和<code>#ifndef</code>是非常重要的，可以防止双重定义的错误。具体而言，其作用是当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p>
</li>
<li><p><code>isatty()</code>：检查给定的设备类型函数名；</p>
</li>
<li><p><code>socket(AF_UNIX, SOCK_STREAM, 0);</code>用于实现同一主机上的进程间通信；</p>
</li>
</ul>
</li>
<li><p><strong>Makefile语法：</strong></p>
<ul>
<li><code>makefile</code>中<code>.PHONY</code>的作用是声明伪目标。声明为为目标后，在执行对应的命令时，make就不会去检查是或否存在对应的文件，而是每次都会运行标签对应的命令；</li>
</ul>
</li>
<li><p><code>patsubst</code>函数用于将文件模式进行替换，其格式为<code>$(patsubst原模式，目标模式，文件列表)</code>；</p>
<ul>
<li>makefile中加入shell指令，以实现自动查找头文件及动态库路径。</li>
</ul>
</li>
<li><p><strong>BIRD使用命令：</strong></p>
<ul>
<li>启动：<code>systemctl start bird</code></li>
<li>停止：<code>systemctl stop bird</code></li>
<li>重启：<code>systemctl restart bird</code></li>
<li>打开/关闭开机自启动：<code>sudo systemctl enable/disable bird</code>；</li>
<li>客户端程序birdc，它可以连接到BIRD服务并且控制它的行为。默认情况下birdc会连接系统服务的BIRD，如果启动BIRD时采用了-s参数，那么birdc也要指定同样的socket路径。</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>20220925-监听网络环境变化</title>
    <url>/2022/09/25/20220925-%E7%9B%91%E5%90%AC%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="监听网络环境变化"><a href="#监听网络环境变化" class="headerlink" title="监听网络环境变化"></a>监听网络环境变化</h3><h4 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h4><p>监听网络环境变化情况一般来说可以通过以下方式进行：</p>
<ul>
<li><p><strong>方式1：<font color='cornflowerblue'>BIRD协议</font>（BFD机制：状态更新间隔调整 + 状态机转换（tla+））</strong></p>
</li>
<li><p><strong>方式2：<font color='cornflowerblue'>libnl</font></strong></p>
</li>
<li><p><strong>方式3：<font color='cornflowerblue'>netlink</font>（<a href="https://blog.csdn.net/hansel/article/details/38088645">参考链接</a>）</strong></p>
</li>
</ul>
<span id="more"></span>
<h4 id="1-libnl概念"><a href="#1-libnl概念" class="headerlink" title="1. libnl概念"></a>1. libnl概念</h4><ul>
<li><p>核心库（core library）提供了使用netlink套接字进行通信的基础功能。它处理套接字的连接建立和断开、发送和接收数据、构造和解析消息、提供可配置的接收状态机。除此之外它还提供了一套抽象数据类型的框架，这套框架使得基于对象的netlink协议实现起来更加简单。在这种协议中，对象可以通过基于netlink的协议来添加、删除或者修改。</p>
<p><img src="http://www.infradead.org/~tgr/libnl/doc/images/library_overview.png" alt="结构层次图"></p>
<ul>
<li>netlink libray：套接字的处理、发送和接收数据、消息的构造和解析；</li>
<li>routing family library：地址、链路、邻居节点、路由、流量控制、邻居节点表；</li>
<li>netfilter library：连接追踪、记录日志、排队；</li>
<li>generice netlink library：控制器的API、协议簇和命令的注册；</li>
</ul>
</li>
</ul>
<h4 id="2-netlink概念"><a href="#2-netlink概念" class="headerlink" title="2. netlink概念"></a>2. netlink概念</h4><ul>
<li>概念：用以实现<strong>用户进程</strong>与<strong>内核进程</strong>通信的一种特殊的进程间通信（IPC），也是网络应用程序与内核通信的最常用的接口；</li>
<li>在linux内核中，使用netlink进行应用与内核通信的应用有很多：<ul>
<li>路由daemon：NETLINK_ROUTE</li>
<li>用户态socket协议：NETLINK_USERSOCK</li>
<li>防火墙：NETLINK_FIREWALL</li>
<li>netfilter子系统：NETLINK_NETFILTER</li>
<li>内核事件向用户态通知：NETLINK_KOBJECT_UEVENT</li>
<li>通用netlink：NETLINK_GENERIC</li>
</ul>
</li>
<li>netlink是一种在内核与用户应用间进行双向数据传输的非常好的方式，用户态应用使用标准的socket API就可以使用gnetlink提供的强大功能，内核态需要使用专门的API来使用netlink；</li>
<li>一般来说，用户空间和内核空间的通信方式有3种：<code>/proc</code>、<code>ioctl</code>、<code>netlink</code>。前两种都是单向的，而netlink可以实现双工通信；</li>
<li>netlink相对于系统调用，ioctl以及<code>/proc</code>文件系统而言，具体有以下优点：<ul>
<li>netlink使用简单，只需要在<code>include/linux/netlink.h</code>中增加一个新类型的netlink协议定义即可（<code>#define NETLINK_TEST 20</code>）。然后，内核和用户态应用就可以立即通过socket API使用该netlink协议类型进行数据交换；</li>
<li>netlink是一种异步通信机制，在内核与用户态应用之间传递的消息保存在socket缓存队列中发送消息只是把消息保存在接收者的socket的接收队列，而不需要等待接收者收到消息；</li>
<li>使用netlink的内核部分可以采用模块的方式实现，使用netlink的应用部分和内核部分没有编译时依赖；</li>
<li>netlink支持多播，内核模块或应用可以把消息多播给一个netlink组，属于该netlink组的任何内核模块或应用都能接收到该消息，内核事件向用户态的通知机制就使用了这一特性；</li>
<li>内核可以使用netlink首先发起会话；</li>
<li>netlink协议基于BSD socket和AF_NETLINK地址簇，使用32位的端口号寻址，每个netlink协议通常与一个或一组内核服务/组件相关联，如NETLINK_ROUTE用于获取和设置路由与链路信息、NETLINK_KOBJECT_UEVENT用于内核向用户空间的udev进程发送通知等；</li>
</ul>
</li>
</ul>
<h4 id="3-ioctl"><a href="#3-ioctl" class="headerlink" title="3. ioctl()"></a>3. ioctl()</h4><p>【未完待续】</p>
]]></content>
  </entry>
</search>
